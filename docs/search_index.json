[["index.html", "CopyKit User Guide 1 Introduction", " CopyKit User Guide Darlan Conterno Minussi Last revised: 2021-12-03 1 Introduction CopyKit provides a suite of tools for pre-processing, quality control, analysis, and visualization of single cell DNA sequencing datasets. The following chapters will cover each module in detail. Generated with CopyKit version: packageVersion(&quot;copykit&quot;) ## [1] &#39;0.0.0.9031&#39; "],["parallelization.html", "2 Parallelization", " 2 Parallelization Whenever possible, CopyKit uses the BiocParallel framework. Running parallel process is highly recommended to speed up CopyKit calculations. Make sure to read the BiocParallel vignette to choose the best parameters for your machine and OS. Use BiocParallel::register() function to register the number of workers desired. library(BiocParallel) register(MulticoreParam(progressbar = T), default = T) Confirm parameters: BiocParallel::bpparam() ## class: MulticoreParam ## bpisup: FALSE; bpnworkers: 124; bptasks: 0; bpjobname: BPJOB ## bplog: FALSE; bpthreshold: INFO; bpstopOnError: TRUE ## bpRNGseed: ; bptimeout: 2592000; bpprogressbar: FALSE ## bpexportglobals: TRUE; bpforceGC: TRUE ## bplogdir: NA ## bpresultdir: NA ## cluster type: FORK Make sure to check the number of workers. Use the argument progressbar to obtain a progress bar. "],["quick-start.html", "3 Quick-Start", " 3 Quick-Start This section provides a basic CopyKit workflow. # Run pre-processing module tumor &lt;- runVarbin(&quot;/path/to/marked/bam/files/&quot;, remove_Y = TRUE) # Mark normal cells if they exist tumor &lt;- findNormalCells(tumor) # Filter cells tumor &lt;- filterCells(tumor) # Visualize the result from filtering and cells marked as diploid plotHeatmap(tumor, label = c(&#39;filtered&#39;, &#39;is_normal&#39;), row_split = &#39;filtered&#39;) # Remove cells marked as normal or noise cells from the copykit object tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$filtered == &quot;kept&quot;] tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$is_normal == FALSE] # Create a umap embedding tumor &lt;- runUmap(tumor) # Search for the best K value for clustering of subclones # according to jaccard similarity and plot the results tumor &lt;- findSuggestedK(tumor) plotSuggestedK(tumor) # Find clusters and plot the results tumor &lt;- findClusters(tumor) plotUmap(tumor, label = &#39;subclones&#39;) # calculating consensus, passed on to plotHeatmap ordering tumor &lt;- calcConsensus(tumor) tumor &lt;- runConsensusPhylo(tumor) # Plot a Copy Number Heatmap with clustering annotation plotHeatmap(tumor, label = &#39;subclones&#39;) The following sections explain all functions in detail. "],["pre-processing.html", "4 Pre-processing 4.1 From BAM files", " 4 Pre-processing CopyKit pre-processing module workhorse is runVarbin() runVarbin() is a wrapper for a series of functions that perform three main processes: Binning and read counting from the .bam files. Counts variance stabilization transformation. Piece-wise segmentation of stabilized counts. We load CopyKit with the library() function. library(copykit) NOTE: Whenever possible, CopyKit functions will run in parallel if the BiocParallel framework was registered. For more information check section parallelization. 4.1 From BAM files 4.1.1 runVarbin() The input for runVarbin() are duplicates marked .bam files. runVarbin() will count the reads into bins according to the variable binning method - Learn More! (Navin et al. 2011; Baslan et al. 2012; Gao et al. 2016). To help users obtain duplicated marked BAM files from .fastq files we provide a snakemake pipeline here.This pipeline can be adapted as per users’ needs. Make sure to align reads to the same genome assembly that will be later used within CopyKit. runVarbin() first argument should be the path to the .bam files: tumor &lt;- runVarbin(&quot;~/path/to/bam/files/&quot;, remove_Y = TRUE) ## Counting reads for genome hg38 and resolution: 200kb ## 34 bam files had less than 10 mean bincounts and were removed. ## Performing GC correction. ## Smoothing bin counts. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. The argument remove_Y provides a convenient shortcut to exclude chromosome Y from the dataset. By default, runVarbin() uses the hg38 genome assembly and a resolution of 220kb. Both options can be customized with the arguments genome or resolution (see ?runVarbin()). The resulting object is the CopyKit object. tumor ## class: CopyKit ## dim: 11268 1502 ## metadata(3): genome resolution vst ## assays(6): bincounts ft ... ratios logr ## rownames(11268): 1 2 ... 11267 11268 ## rowData names(3): gc_content abspos arm ## colnames(1502): PMTC6LiverC100DL1S2_S100_L001_R1_001 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ... PMTC6LiverC9DL1S5_S393_L002_R1_001 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 ## colData names(9): sample reads_assigned_bins ... reads_total percentage_duplicates ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowRanges has: 11268 ranges ## Phylo: Phylogenetic tree with 0 tips and nodes ## consensus dim: 0 0 CopyKit objects inherits from the SingleCellExperiment class. Each column represents a single cell and each row represents a bin. The bin counts are stored in the bincounts assay, which can be acessed with bincounts(). head(bincounts(tumor)[,1:5]) ## # A tibble: 6 × 5 ## PMTC6LiverC100DL1S… PMTC6LiverC100DL1S… PMTC6LiverC100DL4… PMTC6LiverC100DL6… PMTC6LiverC101DL1… ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 37.1 10.3 44.5 44.2 38.6 ## 2 28.8 12.8 53.1 52.0 31.4 ## 3 34.8 9.03 50.4 47.3 31.9 ## 4 24.3 14.2 34.9 35.5 36.9 ## 5 30.8 9.18 55.8 37.1 29.2 ## 6 29.3 5.88 43.0 43.1 38.3 The binned counts are a mixture of poisson distributions with increased variance at higher counts. To address this problem CopyKit performs a variance stabilization transformation (VST) of the count matrix using the Freeman-Tukey transformation. The resulting transformation is stored within the ft assay. IT can be accessed with assay(): head(assay(tumor, &#39;ft&#39;)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 12.258603 6.558716 ## 2 10.832889 7.300770 ## 3 11.880779 6.172013 ## 4 9.951377 7.674830 ## 5 11.181771 6.220463 ## 6 10.921155 5.047847 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 13.42067 13.36691 ## 2 14.63815 14.48431 ## 3 14.27288 13.82443 ## 4 11.89424 12.00304 ## 5 15.01185 12.26513 ## 6 13.19827 13.20130 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 12.50574 ## 2 11.30275 ## 3 11.37859 ## 4 12.23737 ## 5 10.90282 ## 6 12.46409 Lastly, To fit piece-wise constant functions we perform segmentation. The resuolting segment means can be used to infer copy-number states across the different genomic regions. Segmentation method is chosen with the argument method to runVarbin(). Currently available methods are: 4.1.1.1 CBS {DNACopy} By default, CopyKit uses Circular Binary Segmentation (CBS) - Learn More! - from the DNAcopy package to perform segmentation of each chromosome arm. The penalty of the segmentation is controlled by the argument alpha that can be passed on to runVarbin() 4.1.1.2 multipcf {copynumber} A second segmentation option is using the multipcf segmentation from the package copynumber. multipcf differs from CBS by performing a joint segmentation of the samples, resulting in common breakpoints to all samples. The resulting information is stored within the CopyKit object into two different assays: ratios and segment_ratios. They can be accessed with the helper function ratios() and segment_ratios() head(ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 1.11 0.94 ## 2 0.92 1.11 ## 3 1.06 0.85 ## 4 0.81 1.20 ## 5 0.97 0.86 ## 6 0.93 0.61 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 0.96 1.05 ## 2 1.09 1.18 ## 3 1.05 1.10 ## 4 0.80 0.90 ## 5 1.13 0.93 ## 6 0.94 1.03 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 1.03 ## 2 0.88 ## 3 0.89 ## 4 1.00 ## 5 0.84 ## 6 1.02 head(segment_ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 1 1 ## 2 1 1 ## 3 1 1 ## 4 1 1 ## 5 1 1 ## 6 1 1 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 1 1.02 ## 2 1 1.02 ## 3 1 1.02 ## 4 1 1.02 ## 5 1 1.02 ## 6 1 1.02 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 1 ## 2 1 ## 3 1 ## 4 1 ## 5 1 ## 6 1 The following sections describe the functions wrapped by runVarbin(). Important: If you started from runVarbin() you do not need to run the following functions. They are provided to facilitate running modules with different conditions, if needed, in place of re-running runVarbin(). 4.1.1.3 runCountReads() runCountReads()will count the reads into bins, smooth bincounts, and perform GC correction of the counts - Learn More!. The genome argument defines the genome assembly (“hg38,” “hg19”). The resolution argument defines the size of the variable bins (“50kb,” “100kb,” “175kb,” “200kb,” “250kb,” “500kb,” “1Mb,” “2.5Mb”). The argument remove_Y provides a convenient shortcut to exclude chromosome Y from the dataset. 4.1.1.4 runVst() runVst() Performs variance stabilization transformation of the bin counts Available transformations are freeman-tukey (‘ft’) or ‘log.’ 4.1.1.5 runSegmentation() runSegmentation() runs the segmentation algorithm of choice (‘CBS’ or ‘multipcf’), followed by merge levels that do not reach significance Learn More!. 4.1.1.6 logNorm() logNorm() performs a log transformation of the segment_ratios assay and stores into the logr assay. The logr assay is used downstream by functions such as runUmap(). 4.1.2 From external count data or user-defined scaffolds To use CopyKit’s downstream functions with processed datasets, we can create a CopyKit object meeting the following requirements: Either a bin count matrix where columns represent cells and rows are bins (to be stored in the bincounts assay) or a segment mean ratios matrix where columns represent cells and rows represent segment mean for each bin, an integer matrix of copy number calls can also be used at this step (to be stored in the segment_ratios assay). A GenomicRanges object with length equal to the number of bins from the cell assay matrix. As long as the length requirment is respected this allows user-defined scaffolds to be used within CopyKit. To construct the CopyKit object, the following code can be used, if providing bincounts: obj &lt;- CopyKit(list(bincounts = cell_bincount_matrix), rowRanges = genomic_ranges_scaffold) Next, the functions runVst(), runSegmentation(), and logNorm() can be used to continue with the analysis. If providing segment mean ratios obj &lt;- CopyKit(list(segment_ratios = cell_bincount_matrix), rowRanges = genomic_ranges_scaffold) The object can be passed on to the Quality Control and Analysis modules of CopyKit. _PS: If no bincount matrix is provided, functions that require a matrix of bincounts, such as runMetrics() can’t be used in this object. It is useful for downstream functions to add the genome assembly used on the dataset. metadata(obj)$genome &lt;- &quot;hg38&quot; "],["qc-module.html", "5 QC module 5.1 runMetrics() 5.2 findNormalCells() 5.3 filterCells()", " 5 QC module CopyKit QC Module consists of 3 main functions: 1) runMetrics() 2) filterCells() 3) findNormalCells(). 5.1 runMetrics() runMetrics() adds basic quality control information to colData. It returns sample-wise metrics of overdispersion and breakpoint counts. tumor &lt;- runMetrics(tumor) ## Calculating overdispersion. ## Counting breakpoints. ## Done. The resulting information can be seen with: colData(tumor) ## DataFrame with 1502 rows and 11 columns ## sample reads_assigned_bins reads_unmapped ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S2_.. 362665 30250 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 PMTC6LiverC100DL1S6_.. 130570 22260 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL4L5S.. 536017 30942 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 PMTC6LiverC100DL6L7S.. 467002 28239 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 PMTC6LiverC101DL1S2_.. 423654 28756 ## ... ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 PMTC6LiverC99DL4L5S1.. 460498 37945 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 PMTC6LiverC99DL6L7S3.. 306486 28090 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 PMTC6LiverC9DL1S1_S9.. 274402 38326 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 PMTC6LiverC9DL1S5_S3.. 465001 34111 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 PMTC6LiverC9DL6L7S1_.. 336559 38814 ## reads_duplicates reads_multimapped reads_unassigned ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 34883 0 75555 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 12657 0 28651 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 58222 0 110352 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 53055 0 98560 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 43008 0 87786 ## ... ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 54159 0 96735 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 36534 0 64866 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 25527 0 59107 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 48055 0 96126 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 37898 0 71998 ## reads_ambiguous reads_total percentage_duplicates ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 90 503443 0.069 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 27 194165 0.065 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 103 735636 0.079 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 91 646947 0.082 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 76 583280 0.074 ## ... ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 86 649423 0.083 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 56 436032 0.084 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 54 397416 0.064 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 109 643402 0.075 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 60 485329 0.078 ## overdispersion breakpoint_count ## &lt;numeric&gt; &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0.00262992 0 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0.01564945 0 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0.00302844 0 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0.00379236 0 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0.00674672 0 ## ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 0.00195059 0 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0.00362179 0 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0.00406539 0 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0.00276767 0 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 0.00231466 0 5.2 findNormalCells() Datasets may contain normal cells mixed with the aneuploidy cells. To detect diploid cells findNormalCells() calculates the sample-wise coefficient of variation from the segment ratio means. The expected coefficient of variation for diploid cells N(0, 0.01) is simulated for a thousand data points. An expectation-maximization algorithm is used to fit a mixture of normal distributions to the coefficient of variation from the samples together with the simulated datasets. The distribution containing the simulated dataset is inferred to be the diploid distribution. Samples that group with the inferred diploid distribution and present coefficient of variation smaller than 5 standard deviations from the mean diploid distributions are classified as diploid samples. The threshold can be changed from the automatic detection to a custom threshold with the argument resolution. tumor &lt;- findNormalCells(tumor) ## number of iterations= 30 ## Copykit detected 612 that are possibly normal cells using a resolution of: 0.055 ## Added information to colData(CopyKit). The results from findNormalCells() are stored within the colData in the column is_normal. We can visualize the results with plotHeatmap() plotHeatmap(tumor, label = &#39;is_normal&#39;, row_split = &#39;is_normal&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. ## Plotting Heatmap. The object is subsetted in the same way as with any R object. tumor &lt;- tumor[,colData(tumor)$is_normal == FALSE] 5.3 filterCells() filterCells() removes low-quality cells according to a defined resolution threshold. To detect low-quality samples, CopyKit calculates the Pearson correlation matrix of all samples from the segment ratio means. Next, we calculate a sample-wise mean of the correlation between a sample and its k-nearest-neighbors (default = 5). Samples in which the correlation value is lower than the defined threshold are classified as low-quality cells (default = 0.9). tumor &lt;- filterCells(tumor) ## Calculating correlation matrix. ## Marked 100 cells to be removed. ## Adding information to metadata. Access with colData(scCNA). ## Done. The default resolution can be adjusted with the argument ‘resolution.’ Results from filterCells() are added to colData (column filtered) marking cells that should be removed or kept. We can check the results with plotHeatmap(). To make visualization easier, rows can also be split according to elements of colData with the argument row_split. plotHeatmap(tumor, label = &#39;filtered&#39;, row_split = &#39;filtered&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. ## Plotting Heatmap. We remove the marked noise cells from the object with: tumor &lt;- tumor[,colData(tumor)$filtered == &#39;kept&#39;] The dataset should be ready to proceed with the analysis. "],["analysis-and-visualization-module.html", "6 Analysis and Visualization module 6.1 plotMetrics() 6.2 plotRatio() 6.3 runUmap() 6.4 plotUmap() 6.5 Clustering 6.6 runPhylo() 6.7 plotPhylo() 6.8 calcInteger() 6.9 plotHeatmap() 6.10 plotFreq() 6.11 calcConsensus() 6.12 plotConsensusLine() 6.13 findVariableGenes() 6.14 plotVariableGenes() 6.15 plotGeneCopy() 6.16 plotAlluvial()", " 6 Analysis and Visualization module The analysis and visualization module from CopyKit work in synergy to help you analyze and assess the results. 6.1 plotMetrics() plotMetrics() can plot any information available within colData(). names(colData(tumor)) ## [1] &quot;sample&quot; &quot;reads_assigned_bins&quot; &quot;reads_unmapped&quot; ## [4] &quot;reads_duplicates&quot; &quot;reads_multimapped&quot; &quot;reads_unassigned&quot; ## [7] &quot;reads_ambiguous&quot; &quot;reads_total&quot; &quot;percentage_duplicates&quot; ## [10] &quot;overdispersion&quot; &quot;breakpoint_count&quot; &quot;is_normal&quot; ## [13] &quot;find_normal_cv&quot; &quot;filter_corr_value&quot; &quot;filtered&quot; colData information is provided to the argument metric. The argument label, if supplied, will color the points based on that information. plotMetrics(tumor, metric = c(&quot;overdispersion&quot;, &quot;breakpoint_count&quot;, &quot;reads_total&quot;, &quot;reads_duplicates&quot;, &quot;reads_assigned_bins&quot;, &quot;percentage_duplicates&quot;), label = &quot;percentage_duplicates&quot;) ## Coloring by: percentage_duplicates 6.2 plotRatio() It is important to visualize that the segmentation behaved as expected and closely follows the ratios. Ratio plots are a great tool for this. plotRatio() has two different modes. When the input is the CopyKit object, an interactive app will open, allowing selection of which cell will be visualized. plotRatio(tumor) If a sample name is provided to plotRatio(), only the plot for that cell will be shown. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 6.3 runUmap() runUmap() generates a UMAP embedding. The resulting embedding is stored in the reducedDim slot runUmap() is an important pre-processing step to the findClusters() feature. tumor &lt;- runUmap(tumor) ## Using assay: logr ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;umap&#39;). ## Done. Additional arguments to control umap parameters can be passed on torunUmap() with the ‘…’ argument. The full list of additional arguments that can be passed on to uwot::umap with the ‘…’ argument to runUmap() can be seen in the uwot manual. 6.4 plotUmap() plotUmap() can be used to visualize the reduced dimensional embedding. plotUmap can be colored by any element of the colData with the argument ‘label.’ plotUmap(tumor) ## Plotting Umap. 6.5 Clustering findClusters() uses the reduced dimensional embedding resulting from runUmap() to perform clustering at two levels (superclones and subclones). At a more fine-grained resolution, CopyKit can also be used to detect subclones. To do so, the umap embedding is used as the pre-processing step. When clustering for superclones findClusters() creates a graph representation of the reduced dimension embedding using a shared nearest neighbor algorithm (SNN). From this graph the connected components are extracted and generally represent high-level structures that share large copy number events. CopyKit can also be used to detect subclones. The umap embedding used as the pre-processing step. Different clustering algorithms can be used to detect subclones: 1) hdbscan (default) 2) Leiden 3) Louvain The hdbscan method is recommended and has been successfully previously applied in the work from Laks et al. (RN6?). 6.5.1 findSugestedK() To help with parametrization, CopyKit provides the helper findSuggestedK() function. findSuggestedK performs a clustering bootstrapping over a range of k values and returns the value that maximizes the jaccard similarity, by default the metric being maximized is median (argument metric). While findSuggestedK does not guarantee optimal clustering but provides a guide that maximizes cluster stability. tumor &lt;- findSuggestedK(tumor) ## Calculating jaccard similarity for k range: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ## ## Suggested k = 10 with median jaccard similarity of: 1 We can inspect the results of findSuggestedK() with plotSuggestedK(). The default geom plots a boxplot of each k assessed during the grid search as the red point inside each boxplot plotSuggestedK(tumor) In which red dots represent the mean. if the argument geom is set to tile, plotSuggestedK() plots a heatmap where each row is a detected subclone, each column is a k assessed during the grid search and the color represents the jaccard similarity for a given clone. Clones not detected in a given k are presented in gray. plotSuggestedK(tumor, geom = &#39;tile&#39;) It is also possible to visualize the relation between subclone sizes with the jaccard similarity setting geom to scatterplot plotSuggestedK(tumor, geom = &#39;scatterplot&#39;) ## `geom_smooth()` using formula &#39;y ~ x&#39; The suggested value is stored into the metadata and can be accessed at: S4Vectors::metadata(tumor)$suggestedK ## [1] 10 6.5.2 findClusters() To run findClusters() we can provide the CopyKit object. tumor &lt;- findClusters(tumor) ## Using suggested k_subclones = 10 ## Finding clusters, using method: hdbscan ## Found 4 subclones. ## Done. If findSuggestedK() was run prior, and the argument ‘k_subclones’ is not provided, findClusters() will automatically use the value resulting from findSuggestedK() that was stored into the metadata: k values can be manually controlled with ‘k_superclones’ and ‘k_subclones.’ NOTE: k_superclones and k_subclones can be used concurrently. Only k_subclones is a mandatory field. tumor &lt;- findClusters(tumor, k_superclones = 30, k_subclones = 15) If the method used for clustering was hdbscan, it is possible that a subgroup of outliers is identified, those are added to subgroup c0 and may be removed by subsetting the copykit object. Copykit will inform if any cell was classified as c0 in an informative message after running findClusters() tumor &lt;- tumor[,colData(tumor)$subclones != &#39;c0&#39;] We can use different plotting functions to visualize clustering results. For example plotUmap() can be used with the argument ‘label’: plotUmap(tumor, label = &#39;subclones&#39;) ## Plotting Umap. ## Coloring by: subclones. 6.6 runPhylo() To run a phylogenetic analysis use the function runPhylo(). Available methods are Neighbor Joining and Balanced Minimum evolution The resulting tree is stored within the CopyKit object in the phylo slot: tumor &lt;- runPhylo(tumor, metric = &#39;manhattan&#39;) ## Using ratio data... ## Calculating distance matrix ## Creating neighbor-joining tree. ## Access slot with copykit::phylo(scCNA). ## Done. 6.7 plotPhylo() To visualize the resulting phylogenetic trees from runPhylo() we can use the plotPhylo() function. plotPhylo(tumor) plotPhylo() can use any element of the colData to color the leaves of the tree. plotPhylo(tumor, label = &#39;subclones&#39;) 6.8 calcInteger() Segment ratio means can be scaled to integer values with calcInteger(). CopyKit supports different methods of calculating integer copy number profiles. To calculate computational ploidies CopyKit adopts the scquantum package. To use scquantum just set the argument method to scquantum. tumor &lt;- calcInteger(tumor, method = &#39;scquantum&#39;) By setting the argument method to fixed, a fixed value of ploidy (generally determined using Flow Cytometry) will scale all cells. tumor &lt;- calcInteger(tumor, ploidy_value = 4.3) ## Scaling ratio values by ploidy value 4.3 Alternatively, if different ploidies are needed for different cells, a vector containing the ploidies can be passed on to calcInteger(), as long as it is of the same length and sample order as colData() The integer values are stored in the slot integer that can be accessed with the function assay() If the assay integer exists, plotRatio() will use it to plot the integer copy number values as a secondary axis. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 6.9 plotHeatmap() To visualize copy number profiles with a heatmap we can use plotHeatmap() The heatmap can be annotated with elements of colData. To order subclones, one option is to calculate a consensus phylogeny, explained in later sections: tumor &lt;- calcConsensus(tumor) tumor &lt;- runConsensusPhylo(tumor) To plot the heatmap. plotHeatmap(tumor, label = &#39;subclones&#39;) ## Plotting Heatmap. To plot integer copy number heatmaps pass the argument assay = 'integer', importantly the integer matrix must be in the 'integer'slot. plotHeatmap(tumor, assay = &#39;integer&#39;) ## Plotting Heatmap. New information can be added to colData() and used in conjunction with the plotting functions. The example dataset has macro-spatial information. The information is encoded in the sample name by the letter S followed by a number. We can extract that information and add it as an extra column to the metadata: colData(tumor)$spatial_info &lt;- stringr::str_extract(colData(tumor)$sample, &quot;L[0-9]&quot;) Once the information has been added, we can use it to color the umap by their spatial information: plotUmap(tumor, label = &#39;spatial_info&#39;) ## Plotting Umap. ## Coloring by: spatial_info. It is also possible to annotate the heatmap with that information: The ‘label’ argument for plotHeatmap() can add as many annotations as specified by the user as long as they are elements in colData() of the CopyKit object. plotHeatmap(tumor, label = c(&quot;spatial_info&quot;, &quot;subclones&quot;)) ## Plotting Heatmap. If calcInteger() was performed, it is possible to visualize deviations from the expected integer states by using plotHeatmap() with the argument rounding_error set to TRUE plotHeatmap(tumor, label = &#39;subclones&#39;, assay = &#39;integer&#39;, rounding_error = TRUE) ## Plotting Heatmap. 6.10 plotFreq() Computing the frequencies of genomic gain or losses across the genome can be useful to visualize differences between groups. This can be done with plotFreq(). For every region of the genome, plotFreq() will calculate the frequency of gain or losses according to a threshold across all samples. The thresholds are controlled with the arguments low_threshold (values below will be counted as genomic losses) and high_threshold (values above will be counted as genomic gains). Ideally thresholds will be set according to the ploidy of the sample. For example, the sample presented throughout this documentation has a ploidy of approximately 4.3, therefore a gain or loss of one copy number for this sample should have a difference in the segment ratio value of 1/4.3 (~0.23). Therefore we will set the accordingly to a difference of plus or minus 0.2 (leaving some room for error), compared to a segment ratio of 1. The argument assay can be provided to pass on the integer assay instead of the segment_ratios assay (adjust thresholds accordingly). Two geoms are available area or line plotFreq(tumor, low_threshold = 0.8, high_threshold = 1.2) Group information can be set to any categorical element of the colData() and is provided with the argument label. plotFreq(tumor, low_threshold = 0.8, high_threshold = 1.2, label = &#39;spatial_info&#39;) 6.11 calcConsensus() Consensus sequences can help visualize the different segments across subclones. To calculate consensus matrices we can use calcConsensus() tumor &lt;- calcConsensus(tumor) plotHeatmap() can plot a consensus heatmap: plotHeatmap(tumor, consensus = TRUE, label = &#39;subclones&#39;) ## Plotting Heatmap. plotHeatmap() can annotate the consensus heatmap with information from the metadata: plotHeatmap(tumor, consensus = TRUE, label = &#39;subclones&#39;, group = &#39;spatial_info&#39;) ## Plotting Heatmap. By default calcConsensus() uses the subclones information to calculate a consensus for each subclone. Any element of the colData() can be used to calculate the consensus. Note: Consensus matrices can be calculated from the integer assay. Importantly, the integer matrix must be in the assay(tumor, 'integer') slot. Check calcInteger() for more info. tumor &lt;- calcConsensus(tumor, consensus_by = &#39;subclones&#39;, assay = &#39;integer&#39;) 6.12 plotConsensusLine() To compare the differences among subclones, plotConsensusLine() opens an interactive app where the consensus sequences are plotted as lines. plotConsensusLine(tumor) 6.13 findVariableGenes() Finding variable genes can provide important information as to which genes contribute the most to the subclonal structure of the sample. This can be done with findVariableGenes(). findVariableGenes() requires a list of genes with the argument genes. A list of 100 putative oncogenes and tumor supressor genes from Davoli et al. can be found in a vector called tumor_genes, which is loaded with CopyKit. The argument top_n controls the number of genes to be returned tumor &lt;- findVariableGenes(tumor, genes = tumor_genes, top_n = 30) ## Warning in find_scaffold_genes(scCNA, genes = genes): Genes: H3F3A, MYCL1 ,could not be found. ## Maybe you need to use a different gene alias? ## Warning in find_scaffold_genes(scCNA, genes = genes): Genes: CASP8, KMT2C, SMAD2, SMARCB1, VHL are ## in excluded regions of the Varbin pipeline and can&#39;t be plotted. The resulting list of variable genes is stored within the metadata of the CopyKit object. metadata(tumor)$hvg ## [1] &quot;SPOP&quot; &quot;COL1A1&quot; &quot;KIT&quot; &quot;PDGFRA&quot; &quot;NRAS&quot; &quot;KRAS&quot; &quot;MAP3K1&quot; &quot;BCOR&quot; &quot;MDM4&quot; &quot;HRAS&quot; ## [11] &quot;APC&quot; &quot;WT1&quot; &quot;CHEK1&quot; &quot;ATM&quot; &quot;BRCA2&quot; &quot;IL7R&quot; &quot;RB1&quot; &quot;MDM2&quot; &quot;KMT2D&quot; &quot;FLT3&quot; ## [21] &quot;KMT2A&quot; &quot;ATRX&quot; &quot;MED12&quot; &quot;SF3B1&quot; &quot;CDKN1B&quot; &quot;ARID2&quot; &quot;NOTCH2&quot; &quot;U2AF1&quot; &quot;CDH1&quot; &quot;RUNX1&quot; ## attr(,&quot;pca_pc1_loading&quot;) ## CDK4 CDKN1A CDKN1B CDKN2A CHEK1 COL1A1 CTNNB1 ## -0.0045340325 0.0145635126 0.0187141573 0.0041303053 -0.0249086801 -0.3312616233 0.0081528483 ## DAXX DNMT3A EGFR ARID2 EIF4A2 ERBB2 AKT1 ## 0.0124488023 0.0002736062 0.0090880684 -0.0181675486 0.0090386695 -0.0018095380 -0.0031030839 ## ERG AKT2 ETV1 ETV6 FGFR1 FGFR3 FGFR2 ## -0.0171082852 0.0036819005 0.0036797206 0.0138678920 0.0063260209 -0.0089099431 -0.0063315417 ## FLT3 SF3B1 ALK GATA2 GATA3 SETD2 MSH6 ## 0.0225872131 0.0188241390 0.0002559365 -0.0058840115 -0.0032533149 -0.0010700899 0.0004524140 ## APC HRAS IDH1 IDH2 FAS IL7R AR ## -0.0270350999 0.0276488373 0.0133905961 0.0070091073 0.0035455617 0.0245433274 0.0130908383 ## JAK1 JAK2 JUN KIT KRAS SMAD4 MDM2 ## 0.0008393496 0.0067154613 0.0003679612 -0.0400549699 -0.0280258582 -0.0084496655 -0.0234998459 ## MDM4 MAP3K1 MEN1 MET MLH1 KMT2A MSH2 ## -0.0279061678 -0.0279743907 -0.0165177434 0.0064579789 0.0142131204 -0.0225676782 0.0004524140 ## MYB MYC MYCN MYD88 ATM NF1 NF2 ## 0.0054554949 -0.0037620189 0.0027529446 0.0104520178 -0.0248946576 -0.0026521502 -0.0044624313 ## NOTCH1 NOTCH2 NRAS PDGFRA PIK3CA ATR ATRX ## -0.0019571929 -0.0181459634 -0.0287684764 -0.0400549699 0.0116159427 0.0065627076 0.0213214540 ## TET2 BCOR PPP2R1A FBXW7 PTEN ARID1B RB1 ## 0.0008010354 0.0279230042 0.0004775173 -0.0051551503 0.0033928939 0.0010299148 0.0242380136 ## CCND1 BCL6 MAP2K4 SMARCA4 SOX2 BRCA1 BRAF ## -0.0171269889 0.0083601802 0.0036106061 0.0056435780 0.0113975488 -0.0018095380 0.0094806225 ## BRCA2 STK11 TP53 TSC1 TSC2 U2AF1 WT1 ## 0.0246665410 0.0049845861 0.0062645053 -0.0024499151 0.0010017439 -0.0180954695 0.0252981221 ## KMT2D ARID1A AXIN1 BAP1 SPOP RUNX1 CCNE1 ## 0.0233004924 0.0075469864 0.0010017439 0.0032952326 -0.9321867853 -0.0172046186 -0.0098847786 ## MED12 CDH1 ## 0.0199529879 0.0176253717 ## attr(,&quot;pca_df&quot;) ## gene p1 ## SPOP SPOP -0.9321867853 ## COL1A1 COL1A1 -0.3312616233 ## KIT KIT -0.0400549699 ## PDGFRA PDGFRA -0.0400549699 ## NRAS NRAS -0.0287684764 ## KRAS KRAS -0.0280258582 ## MAP3K1 MAP3K1 -0.0279743907 ## BCOR BCOR 0.0279230042 ## MDM4 MDM4 -0.0279061678 ## HRAS HRAS 0.0276488373 ## APC APC -0.0270350999 ## WT1 WT1 0.0252981221 ## CHEK1 CHEK1 -0.0249086801 ## ATM ATM -0.0248946576 ## BRCA2 BRCA2 0.0246665410 ## IL7R IL7R 0.0245433274 ## RB1 RB1 0.0242380136 ## MDM2 MDM2 -0.0234998459 ## KMT2D KMT2D 0.0233004924 ## FLT3 FLT3 0.0225872131 ## KMT2A KMT2A -0.0225676782 ## ATRX ATRX 0.0213214540 ## MED12 MED12 0.0199529879 ## SF3B1 SF3B1 0.0188241390 ## CDKN1B CDKN1B 0.0187141573 ## ARID2 ARID2 -0.0181675486 ## NOTCH2 NOTCH2 -0.0181459634 ## U2AF1 U2AF1 -0.0180954695 ## CDH1 CDH1 0.0176253717 ## RUNX1 RUNX1 -0.0172046186 ## CCND1 CCND1 -0.0171269889 ## ERG ERG -0.0171082852 ## MEN1 MEN1 -0.0165177434 ## CDKN1A CDKN1A 0.0145635126 ## MLH1 MLH1 0.0142131204 ## ETV6 ETV6 0.0138678920 ## IDH1 IDH1 0.0133905961 ## AR AR 0.0130908383 ## DAXX DAXX 0.0124488023 ## PIK3CA PIK3CA 0.0116159427 ## SOX2 SOX2 0.0113975488 ## MYD88 MYD88 0.0104520178 ## CCNE1 CCNE1 -0.0098847786 ## BRAF BRAF 0.0094806225 ## EGFR EGFR 0.0090880684 ## EIF4A2 EIF4A2 0.0090386695 ## FGFR3 FGFR3 -0.0089099431 ## SMAD4 SMAD4 -0.0084496655 ## BCL6 BCL6 0.0083601802 ## CTNNB1 CTNNB1 0.0081528483 ## ARID1A ARID1A 0.0075469864 ## IDH2 IDH2 0.0070091073 ## JAK2 JAK2 0.0067154613 ## ATR ATR 0.0065627076 ## MET MET 0.0064579789 ## FGFR2 FGFR2 -0.0063315417 ## FGFR1 FGFR1 0.0063260209 ## TP53 TP53 0.0062645053 ## GATA2 GATA2 -0.0058840115 ## SMARCA4 SMARCA4 0.0056435780 ## MYB MYB 0.0054554949 ## FBXW7 FBXW7 -0.0051551503 ## STK11 STK11 0.0049845861 ## CDK4 CDK4 -0.0045340325 ## NF2 NF2 -0.0044624313 ## CDKN2A CDKN2A 0.0041303053 ## MYC MYC -0.0037620189 ## AKT2 AKT2 0.0036819005 ## ETV1 ETV1 0.0036797206 ## MAP2K4 MAP2K4 0.0036106061 ## FAS FAS 0.0035455617 ## PTEN PTEN 0.0033928939 ## BAP1 BAP1 0.0032952326 ## GATA3 GATA3 -0.0032533149 ## AKT1 AKT1 -0.0031030839 ## MYCN MYCN 0.0027529446 ## NF1 NF1 -0.0026521502 ## TSC1 TSC1 -0.0024499151 ## NOTCH1 NOTCH1 -0.0019571929 ## ERBB2 ERBB2 -0.0018095380 ## BRCA1 BRCA1 -0.0018095380 ## SETD2 SETD2 -0.0010700899 ## ARID1B ARID1B 0.0010299148 ## TSC2 TSC2 0.0010017439 ## AXIN1 AXIN1 0.0010017439 ## JAK1 JAK1 0.0008393496 ## TET2 TET2 0.0008010354 ## PPP2R1A PPP2R1A 0.0004775173 ## MSH6 MSH6 0.0004524140 ## MSH2 MSH2 0.0004524140 ## JUN JUN 0.0003679612 ## DNMT3A DNMT3A 0.0002736062 ## ALK ALK 0.0002559365 Results are presented from most variable to list variable. The results can be visualized with plotVariableGenes() and plotGeneCopy(). Note: Genes with large diversity of copy number states tend to be oncogenes, Using findVariableGenes() as a discovery tool can under represent events in tumor supressor genes that tend to be deleted. Genes can be annotated to a heatmap in plotHeatmap() with the genes argument. plotHeatmap(tumor, label = &#39;subclones&#39;, genes = metadata(tumor)$hvg) ## Plotting Heatmap. The genes argument can be a vector of gene HUGO symbols: plotHeatmap(tumor, label = &#39;subclones&#39;, genes = c(&quot;TP53&quot;, &quot;BRAF&quot;, &quot;MYC&quot;)) 6.14 plotVariableGenes() plotVariableGenes() is a visualization for the results from findVariableGenes(). plotVariableGenes(tumor) 6.15 plotGeneCopy() To check copy number states across of genes we can use plotGeneCopy(). Two different geoms: “swarm” (default) or “violin” can be applied. As with other plotting functions, points can be colored with the argument ‘label.’ plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), label = &#39;spatial_info&#39;) ## Coloring by: spatial_info plotGeneCopy() can be specially useful to visualize the result from findVariableGenes() plotGeneCopy(tumor, genes = metadata(tumor)$hvg, label = &#39;spatial_info&#39;) ## Coloring by: spatial_info A barplot geom is also provided to visualize the integer data as a frequency barplot for each gene: plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), geom = &#39;barplot&#39;, assay = &#39;integer&#39;) 6.16 plotAlluvial() To visualize frequencies across elements of the metadata we can use plotAlluvial() plotAlluvial(tumor, label = c(&quot;subclones&quot;, &quot;spatial_info&quot;)) "],["learn-more.html", "7 Learn more 7.1 Copy Number data from short reads sequencing 7.2 Principle 7.3 VarBin 7.4 GC correction 7.5 Merge Levels 7.6 Segmentation", " 7 Learn more 7.1 Copy Number data from short reads sequencing 7.2 Principle To infer copy number data from short-read sequencing we count the number of reads that align to a particular region of the genome. Counterintuitively, we are not drawn to the individual nucleotides, but the regions of the genome in which the reads have aligned. 7.3 VarBin To perform the alignment of millions of reads in a reasonable time frame, aligners trade-off accuracy for speed. Furthermore, the genome is filled with repetitive and hard to map regions. As a consequence, errors produced during the process of alignment are known as mapping errors. Mapping errors may be a significant source of bias. Correct estimation of copy number gains or losses is dependent on accurate control of different biases. To infer copy number variations and account for sources of bias, different methods have been developed, including the Variable Binning method. The VarBin method accounts for mapping bias by partitioning the genome into bins of variable sizes. The guiding principle is, if we were to map a diploid genome to our scaffold, each bin will receive an equal number of reads. To construct the VarBin scaffolds, reads are simulated from a reference genome and mapped back. The reference genome is partitioned into bins of variable sizes, that receive an equal amount of reads. We can construct scaffolds of different resolutions. Higher resolutions will have smaller bin sizes and detect more ‘focal’ copy number events. The decision of which resolution to use is dependent on diverse factors. Those include the library complexity, number of multiplexed cells, sequencer output, among others. Generally, a target of 1M reads/cell, with a 10% PCR duplicate rate, is sufficient to generate high-quality copy number profiles for the 220kb scaffold. 7.4 GC correction GC-content can be a source of bias within the counts. Normalization of GC content is performed as follows: Both fragment counts and GC counts are binned to a bin-size of choice. A curve describing the conditional mean fragment count per GC value is estimated. The resulting GC curve determines a predicted count for each bin based on the bin’s GC. These predictions can be used directly to normalize the original signal, or as the rates for a heterogeneous Poisson model. extracted from: Summarizing and correcting the GC content bias in high-throughput sequencing. Benjamini &amp; Speed Therefore, we smooth the signal using loess normalization. 7.5 Merge Levels After segmentation, some segments remain with small differences, generating spurious breakpoints that are unlikely to be real copy number events. To remove this effect we perform a Wilcoxon rank-sum test between the observed median across two segments. Segments that do not reach significance are merged. 7.6 Segmentation 7.6.1 CBS Circular Binary Segmentation (CBS) is a popular method of segmentation. From the help of DNAcopy package (see ?DNAcopy::segment): This function implements the circular binary segmentation (CBS) algorithm of Olshen and Venkatraman (2004). Given a set of genomic data, either continuous or binary, the algorithm recursively splits chromosomes into either two or three subsegments based on a maximum t-statistic. A reference distribution, used to decided whether or not to split, is estimated by permutation. Options are given to eliminate splits when the means of adjacent segments are not sufficiently far apart. Note that after the first split the α-levels of the tests for splitting are not unconditional. "],["session-info.html", "8 Session Info", " 8 Session Info sessionInfo() ## R version 4.1.1 (2021-08-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.3 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 ## [4] LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C ## [10] LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] BiocParallel_1.28.0 bookdown_0.24 copykit_0.0.0.9031 ## [4] DNAcopy_1.68.0 Rsubread_2.8.1 SingleCellExperiment_1.16.0 ## [7] SummarizedExperiment_1.24.0 Biobase_2.54.0 GenomicRanges_1.46.0 ## [10] GenomeInfoDb_1.30.0 IRanges_2.28.0 S4Vectors_0.32.2 ## [13] BiocGenerics_0.40.0 MatrixGenerics_1.6.0 matrixStats_0.61.0 ## ## loaded via a namespace (and not attached): ## [1] rappdirs_0.3.3 rtracklayer_1.54.0 prabclus_2.3-2 ## [4] coda_0.19-4 tidyr_1.1.4 ggplot2_3.3.5 ## [7] clusterGeneration_1.3.7 bit64_4.0.5 knitr_1.36 ## [10] irlba_2.3.3 DelayedArray_0.20.0 KEGGREST_1.34.0 ## [13] RCurl_1.98-1.5 doParallel_1.0.16 generics_0.1.1 ## [16] GenomicFeatures_1.46.1 ScaledMatrix_1.2.0 cowplot_1.1.1 ## [19] RSQLite_2.2.8 combinat_0.0-8 bit_4.0.4 ## [22] xml2_1.3.2 lubridate_1.8.0 httpuv_1.6.3 ## [25] assertthat_0.2.1 viridis_0.6.2 amap_0.8-18 ## [28] xfun_0.28 jquerylib_0.1.4 hms_1.1.1 ## [31] evaluate_0.14 promises_1.2.0.1 DEoptimR_1.0-9 ## [34] fansi_0.5.0 restfulr_0.0.13 progress_1.2.2 ## [37] dbplyr_2.1.1 igraph_1.2.8 DBI_1.1.1 ## [40] tmvnsim_1.0-2 paletteer_1.4.0 purrr_0.3.4 ## [43] ellipsis_0.3.2 RSpectra_0.16-0 dplyr_1.0.7 ## [46] ggnewscale_0.4.5 backports_1.3.0 biomaRt_2.50.0 ## [49] sparseMatrixStats_1.6.0 vctrs_0.3.8 ggalluvial_0.12.3 ## [52] cachem_1.0.6 robustbase_0.93-9 GenomicAlignments_1.30.0 ## [55] treeio_1.18.0 prettyunits_1.1.1 scran_1.22.0 ## [58] mclust_5.4.7 mnormt_2.0.2 phytools_0.7-90 ## [61] cluster_2.1.2 ape_5.5 segmented_1.3-4 ## [64] lazyeval_0.2.2 crayon_1.4.2 labeling_0.4.2 ## [67] edgeR_3.36.0 pkgconfig_2.0.3 vipor_0.4.5 ## [70] nlme_3.1-153 nnet_7.3-16 pals_1.7 ## [73] rlang_0.4.12 diptest_0.76-0 lifecycle_1.0.1 ## [76] miniUI_0.1.1.1 filelock_1.0.2 dbscan_1.1-8 ## [79] BiocFileCache_2.2.0 rsvd_1.0.5 dichromat_2.0-0 ## [82] Matrix_1.3-4 aplot_0.1.1 phangorn_2.7.1 ## [85] boot_1.3-28 beeswarm_0.4.0 GlobalOptions_0.1.2 ## [88] viridisLite_0.4.0 png_0.1-7 rjson_0.2.20 ## [91] bitops_1.0-7 Biostrings_2.62.0 blob_1.2.2 ## [94] DelayedMatrixStats_1.16.0 shape_1.4.6 stringr_1.4.0 ## [97] gridGraphics_0.5-1 beachmat_2.10.0 scales_1.1.1 ## [100] memoise_2.0.0 magrittr_2.0.1 zlibbioc_1.40.0 ## [103] compiler_4.1.1 dqrng_0.3.0 BiocIO_1.4.0 ## [106] RColorBrewer_1.1-2 plotrix_3.8-2 clue_0.3-60 ## [109] cli_3.1.0 Rsamtools_2.10.0 snakecase_0.11.0 ## [112] XVector_0.34.0 patchwork_1.1.1 mgcv_1.8-38 ## [115] MASS_7.3-54 tidyselect_1.1.1 stringi_1.7.5 ## [118] forcats_0.5.1 highr_0.9 purler_0.1.1 ## [121] yaml_2.2.1 BiocSingular_1.10.0 locfit_1.5-9.4 ## [124] grid_4.1.1 sass_0.4.0 fastmatch_1.1-3 ## [127] tools_4.1.1 parallel_4.1.1 circlize_0.4.13 ## [130] rstudioapi_0.13 bluster_1.4.0 foreach_1.5.1 ## [133] gridExtra_2.3 janitor_2.1.0 metapod_1.2.0 ## [136] farver_2.1.0 scatterplot3d_0.3-41 digest_0.6.28 ## [139] FNN_1.1.3 shiny_1.7.1 quadprog_1.5-8 ## [142] fpc_2.2-9 Rcpp_1.0.7 broom_0.7.10 ## [145] scuttle_1.4.0 later_1.3.0 httr_1.4.2 ## [148] AnnotationDbi_1.56.1 ComplexHeatmap_2.10.0 kernlab_0.9-29 ## [151] colorspace_2.0-2 XML_3.99-0.8 reticulate_1.22 ## [154] splines_4.1.1 uwot_0.1.10 yulab.utils_0.0.4 ## [157] statmod_1.4.36 rematch2_2.1.2 tidytree_0.3.5 ## [160] expm_0.999-6 aCGH_1.72.0 multtest_2.50.0 ## [163] mapproj_1.2.7 ggplotify_0.1.0 flexmix_2.3-17 ## [166] xtable_1.8-4 jsonlite_1.7.2 ggtree_3.2.0 ## [169] modeltools_0.2-23 ggfun_0.0.4 R6_2.5.1 ## [172] pillar_1.6.4 htmltools_0.5.2 mime_0.12 ## [175] glue_1.4.2 fastmap_1.1.0 BiocNeighbors_1.12.0 ## [178] class_7.3-19 codetools_0.2-18 maps_3.4.0 ## [181] utf8_1.2.2 bslib_0.3.1 lattice_0.20-45 ## [184] tibble_3.1.5 mixtools_1.2.0 numDeriv_2016.8-1.1 ## [187] ggbeeswarm_0.6.0 curl_4.3.2 leiden_0.3.9 ## [190] gtools_3.9.2 magick_2.7.3 survival_3.2-13 ## [193] limma_3.50.0 rmarkdown_2.11 munsell_0.5.0 ## [196] GetoptLong_1.0.5 fastcluster_1.2.3 GenomeInfoDbData_1.2.7 ## [199] iterators_1.0.13 gtable_0.3.0 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
