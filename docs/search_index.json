[["index.html", "CopyKit User Guide 1 Introduction", " CopyKit User Guide Darlan Conterno Minussi Last revised: 2023-02-08 1 Introduction CopyKit logo The goal of CopyKit is to help you analyze single cell DNA sequencing datasets for copy number. For that, CopyKit presents four modules: - Pre-processing - Quality Control - Data Analysis - Visualization The following chapters will cover each module in detail. copykit cheat sheet Generated with CopyKit version: packageVersion(&quot;copykit&quot;) ## [1] &#39;0.1.2&#39; "],["parallelization.html", "2 Parallelization", " 2 Parallelization Whenever possible, CopyKit uses the BiocParallel framework. Running parallel processes is highly recommended to speed up CopyKit calculations. Make sure to read the BiocParallel vignette to choose the best parameters for your machine and OS. Use BiocParallel::register() function to register the number of workers (threads) desired. To visually monitor the progress, you can use the argument progressbar. library(BiocParallel) register(MulticoreParam(progressbar = T, workers = 8), default = T) Confirm parameters: BiocParallel::bpparam() Note about plotHeatmap() function parallelization: plotHeatmap() uses a different framework and requires the argument n_threads to set the number of threads when in use with the argument order_cells = hclust. This is to speed up the calculation of a distance matrix. Using more threads when ordering the heatmap with hclust will significantly speed up the plotting of the heatmap. See example in plotHeatmap help. "],["quick-start.html", "3 Quick-Start", " 3 Quick-Start This section provides a basic CopyKit workflow. # Load library library(copykit) # Run pre-processing module tumor &lt;- runVarbin(&quot;/path/to/marked/bam/files/&quot;, remove_Y = TRUE) # Mark euploid cells if they exist tumor &lt;- findAneuploidCells(tumor) # Mark low-quality cells for filtering tumor &lt;- findOutliers(tumor) # Visualize cells labeled by filter and aneuploid status plotHeatmap(tumor, label = c(&#39;outlier&#39;, &#39;is_aneuploid&#39;), row_split = &#39;outlier&#39;) # Remove cells marked as low-quality and/or aneuploid from the copykit object tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$outlier == FALSE] tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$is_aneuploid == TRUE] # kNN smooth profiles tumor &lt;- knnSmooth(tumor) # Create a umap embedding tumor &lt;- runUmap(tumor) # Search for the K value that maximizes jaccard similarity for clustering of subclones # Plot the results # This step is optional. A fixed K value can be provided later to findClusters() tumor &lt;- findSuggestedK(tumor) plotSuggestedK(tumor) # Find clusters of similar copy number profiles and plot the results # If no k_subclones value is provided, automatically detect it from findSuggestedK() tumor &lt;- findClusters(tumor) plotUmap(tumor, label = &#39;subclones&#39;) # Calculate consensus profiles for each subclone, # and order cells by cluster for visualization with plotHeatmap tumor &lt;- calcConsensus(tumor) tumor &lt;- runConsensusPhylo(tumor) # Plot a copy number heatmap with clustering annotation plotHeatmap(tumor, label = &#39;subclones&#39;) The following sections explain all functions in detail. "],["pre-processing.html", "4 Pre-processing 4.1 From Single Cell BAM files 4.2 runVarbin() modules 4.3 From external count data or user-defined scaffolds", " 4 Pre-processing CopyKit’s pre-processing module workhorse is runVarbin() runVarbin() is a wrapper for a series of functions that perform three main processes: Binning and read counting from the .bam files Applying a variance stabilization transformation to the bin counts Piece-wise segmentating stabilized bin counts We load CopyKit with the library() function. library(copykit) NOTE: If the BiocParallel framework was registered, CopyKit functions will, whenever possible, run in parallel. For more information check the parallelization section. 4.1 From Single Cell BAM files 4.1.1 runVarbin() The runVarbin() function takes in the file path of the folder where your marked duplicate BAM files are located. Each cell must be its own BAM file. For Chromium single cell CNA users (10X Genomics), this means splitting the possorted.bam file by cell barcode into individual BAM files. If files are originated from paired-end sequencing, please ensure that the argument “is_paired_end” is set to TRUE during `runVarbin(). Once run, runVarbin() uses the variable binning method to count the number of reads in each genomic bin. - Learn More!. A snakemake pipeline is provided here to convert FASTQ files to marked BAM files, but it is not a required step. If you already have marked BAM files from another source, you can skip this step. Note that the reads must be aligned to the same genome assembly as used in CopyKit. The input for runVarbin() is the path of the folder containing your marked duplicate .bam files. An optional second argument remove_Y provides a convenient shortcut to exclude chromosome Y from the dataset. To learn about all arguments that runVarbin() accepts use ?runVarbin tumor &lt;- runVarbin(&quot;~/path/to/bam/files/&quot;, remove_Y = TRUE) ## Counting reads for genome hg38 and resolution: 220kb ## 34 bam files had less than 10 mean bincounts and were removed. ## Performing GC correction. ## Running variance stabilization transformation: ft ## Smoothing outlier bins. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. The runVarbin() function uses the hg38 genome assembly and a 220kb bin resolution by default, but these can be adjusted using the \"genome\" or \"resolution\" arguments. If your BAM files come from paired-end sequencing, be sure to set the \"is_paired_end\" argument to TRUE. (See the function documentation for more information: ?runVarbin) tumor &lt;- runVarbin(&quot;~/path/to/bam/files/&quot;, remove_Y = TRUE, is_paired_end = TRUE) The resulting object is the CopyKit object. tumor ## class: CopyKit ## dim: 11268 1502 ## metadata(3): genome resolution vst ## assays(6): bincounts ft ... ratios logr ## rownames(11268): 1 2 ... 11267 11268 ## rowData names(3): gc_content abspos arm ## colnames(1502): ## PMTC6LiverC100DL1S2_S100_L001_R1_001 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ... ## PMTC6LiverC9DL1S5_S393_L002_R1_001 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 ## colData names(9): sample reads_assigned_bins ... ## reads_total percentage_duplicates ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowRanges has: 11268 ranges ## Phylo: Phylogenetic tree with 0 tips and nodes ## consensus dim: 0 0 CopyKit objects inherit from the SingleCellExperiment class. Each column corresponds to a single cell and each row corresponds to a bin. The bincounts assay, which can be accessed using the bincounts() function, stores the read counts for each bin. head(bincounts(tumor)[,1:5]) ## # A tibble: 6 × 5 ## PMTC6LiverC100DL1S2_S… PMTC6LiverC100D… PMTC6LiverC100D… ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 37.1 10.3 44.5 ## 2 28.8 12.8 53.1 ## 3 34.8 9.03 50.4 ## 4 24.3 14.2 34.9 ## 5 30.8 9.18 55.8 ## 6 29.3 5.88 43.0 ## # … with 2 more variables: ## # PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 &lt;dbl&gt;, ## # PMTC6LiverC101DL1S2_S101_L001_R1_001 &lt;dbl&gt; To address overdispersion, CopyKit performs a variance stabilization transformation (VST) of the count matrix using the Freeman-Tukey transformation. Alternatively, log transformation is also available (see the function documentation for more information ?runVst()) The resulting transformation is stored within the ft assay, which can be accessed with assay(): head(assay(tumor, &#39;ft&#39;)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 ## 1 12.258603 ## 2 10.832889 ## 3 11.880779 ## 4 9.951377 ## 5 11.181771 ## 6 10.921155 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 6.558716 ## 2 7.300770 ## 3 6.172013 ## 4 7.674830 ## 5 6.220463 ## 6 5.047847 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 ## 1 13.42067 ## 2 14.63815 ## 3 14.27288 ## 4 11.89424 ## 5 15.01185 ## 6 13.19827 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 13.36691 ## 2 14.48431 ## 3 13.82443 ## 4 12.00304 ## 5 12.26513 ## 6 13.20130 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 12.50574 ## 2 11.30275 ## 3 11.37859 ## 4 12.23737 ## 5 10.90282 ## 6 12.46409 We use segmentation to divide the genome-ordered bin counts into piecewise constant segments, and the means of these segments can be used to infer copy number states across the genomic regions. The runVarbin() function allows for the selection of different segmentation methods using the method argument, which can be set to either CBS or multipcf. By default, the function uses the Circular Binary Segmentation (CBS) - Learn More! - method from the DNAcopy package. An additional argument, alpha, controls the significance levels required to accept change-points. The second segmentation option is the Multi-sample Piecewise Constant Fit (multipcf) segmentation from the copynumber package, which performs a joint segmentation of the samples and identifies common breakpoints across all samples. The resulting segmentation is stored within the CopyKit object into two different assays: ratios and segment_ratios. Learn More! which can be accessed with the functions ratios() and segment_ratios() head(ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 ## 1 1.15 ## 2 0.89 ## 3 1.08 ## 4 0.75 ## 5 0.95 ## 6 0.91 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 0.90 ## 2 1.13 ## 3 0.80 ## 4 1.25 ## 5 0.81 ## 6 0.52 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 ## 1 0.94 ## 2 1.12 ## 3 1.06 ## 4 0.74 ## 5 1.18 ## 6 0.91 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 1.06 ## 2 1.25 ## 3 1.14 ## 4 0.86 ## 5 0.89 ## 6 1.04 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 1.03 ## 2 0.84 ## 3 0.85 ## 4 0.99 ## 5 0.78 ## 6 1.03 head(segment_ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 ## 1 1 ## 2 1 ## 3 1 ## 4 1 ## 5 1 ## 6 1 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 0.99 ## 2 0.99 ## 3 0.99 ## 4 0.99 ## 5 0.99 ## 6 0.99 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 ## 1 1 ## 2 1 ## 3 1 ## 4 1 ## 5 1 ## 6 1 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 1.03 ## 2 1.03 ## 3 1.03 ## 4 1.03 ## 5 1.03 ## 6 1.03 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 1 ## 2 1 ## 3 1 ## 4 1 ## 5 1 ## 6 1 4.2 runVarbin() modules The runVarbin() module includes the following functions, which are detailed below. It is important to note that if you have already started from runVarbin(), you do not need to run these functions again. The details of these functions is to enable you to run the modules under different conditions without requiring you to re-run all runVarbin() module. 4.2.0.1 runCountReads() The runCountReads() function counts the reads into bins, and performs GC correction of the counts - Learn More!. The genome argument defines the genome assembly (“hg38”, “hg19”) and the resolution argument specifies the size of the variable bins (“55kb”, “110kb”, “195kb”, “220kb”, “280kb”, “500kb”, “1Mb”, “2.8Mb”). The remove_Y argument provides a convenient shortcut to exclude the chromosome Y from the dataset. 4.2.0.2 runVst() The runVst() function performs variance stabilization transformation on the bin counts, using either the freeman-tukey (‘ft’) or ‘log’ transformation. 4.2.0.3 runSegmentation() The runSegmentation() function runs either the ‘CBS’ or ‘multipcf’ segmentation, and then merges consecutive segments that don’t reach the significance threshold Learn More!. The argument alpha controls the significance threshold for CBS segmentation, whil th gamma argument controls the penalty for the multipcf segmentation. 4.2.0.4 logNorm() logNorm() performs a log transformation of the segment_ratios assay and stores into the logr assay. The logr assay is used downstream by functions such as runUmap(). 4.3 From external count data or user-defined scaffolds To use CopyKit’s downstream functions with processed datasets, we can create a CopyKit object meeting the following requirements: Either a bin count matrix where columns represent cells and rows represent bins (to be stored in the bincounts assay) or a segment mean ratios matrix where columns represent cells and rows represent segment mean values for each bin. An integer matrix of copy number calls can also be used at this step (to be stored in the segment_ratios assay). A GenomicRanges object with length equal to the number of bins from the cell assay matrix. As long as the length requirement is respected this allows user-defined scaffolds to be used within CopyKit. To construct the CopyKit object, the following mock code is presented as an example. If providing bincounts: obj &lt;- CopyKit(list(bincounts = cell_bincount_matrix), rowRanges = genomic_ranges_scaffold) If providing bincounts, the functions runVst(), runSegmentation(), and logNorm() can be used to continue with the analysis. To obtain variance stabilized counts, and segment ratio means. If providing segment mean ratios: obj &lt;- CopyKit(list(segment_ratios = cell_bincount_matrix), rowRanges = genomic_ranges_scaffold) It is useful to call logNorm() and set the logr slot for downstream functions. The resulting object can then be passed on to the Quality Control and Analysis modules of CopyKit. Furthermore, it is useful for downstream functions to add the genome assembly used on the dataset. metadata(obj)$genome &lt;- &quot;hg38&quot; NOTE: If no bincount matrix is provided, functions that require a matrix of bincounts, such as runMetrics() can’t be used with this object. "],["qc-module.html", "5 QC module 5.1 runMetrics() 5.2 findAneuploidCells() 5.3 findOutliers()", " 5 QC module CopyKit Quality Control Module consists of 3 main functions: runMetrics() findOutliers() findAneuploidCells(). 5.1 runMetrics() runMetrics() adds basic quality control information to colData. It returns sample-wise metrics of overdispersion and breakpoint counts. tumor &lt;- runMetrics(tumor) ## Calculating overdispersion. ## Counting breakpoints. ## Done. The resulting information can be viewed with: colData(tumor) ## DataFrame with 1502 rows and 11 columns ## sample ## &lt;character&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S2_.. ## PMTC6LiverC100DL1S6_S484_L002_R1_001 PMTC6LiverC100DL1S6_.. ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL4L5S.. ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 PMTC6LiverC100DL6L7S.. ## PMTC6LiverC101DL1S2_S101_L001_R1_001 PMTC6LiverC101DL1S2_.. ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 PMTC6LiverC99DL4L5S1.. ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 PMTC6LiverC99DL6L7S3.. ## PMTC6LiverC9DL1S1_S9_L001_R1_001 PMTC6LiverC9DL1S1_S9.. ## PMTC6LiverC9DL1S5_S393_L002_R1_001 PMTC6LiverC9DL1S5_S3.. ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 PMTC6LiverC9DL6L7S1_.. ## reads_assigned_bins ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 362665 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 130570 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 536017 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 467002 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 423654 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 460498 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 306486 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 274402 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 465001 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 336559 ## reads_unmapped ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 30250 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 22260 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 30942 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 28239 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 28756 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 37945 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 28090 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 38326 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 34111 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 38814 ## reads_duplicates ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 34883 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 12657 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 58222 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 53055 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 43008 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 54159 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 36534 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 25527 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 48055 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 37898 ## reads_multimapped ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 0 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 0 ## reads_unassigned ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 75555 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 28651 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 110352 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 98560 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 87786 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 96735 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 64866 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 59107 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 96126 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 71998 ## reads_ambiguous ## &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 90 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 27 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 103 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 91 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 76 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 86 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 56 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 54 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 109 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 60 ## reads_total ## &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 503443 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 194165 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 735636 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 646947 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 583280 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 649423 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 436032 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 397416 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 643402 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 485329 ## percentage_duplicates ## &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0.069 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0.065 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0.079 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0.082 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0.074 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 0.083 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0.084 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0.064 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0.075 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 0.078 ## overdispersion ## &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0.00262992 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0.01564945 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0.00302844 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0.00379236 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0.00674672 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 0.00195059 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0.00362179 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0.00406539 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0.00276767 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 0.00231466 ## breakpoint_count ## &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 1 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 2 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 1 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 2 5.2 findAneuploidCells() Datasets may contain euploid cells mixed with the aneuploidy cells. To detect euploid cells findAneuploidCells() calculates the sample-wise coefficient of variation from the segment ratio means. The expected coefficient of variation for euploid cells N(0, 0.01) is simulated for x data points, where x is equal to the number of cells within the dataset. An expectation-maximization algorithm is used to fit a mixture of gaussian distributions to the coefficient of variation from the samples together with the simulated datasets. The distribution containing the simulated dataset is inferred to be the euploid distribution. Samples that group with the inferred euploid distribution and present coefficient of variation smaller than 5 standard deviations from the mean euploid distribution are classified as euploid samples. The threshold can be changed from the automatic detection to a custom threshold with the argument resolution. For example, by setting a threshold = 0.1, findAneuploidCells will mark as euploid all cells with a coefficient of variation less or equal than 0.1. tumor &lt;- findAneuploidCells(tumor) ## number of iterations= 23 ## Copykit detected 610 that are possibly diploid cells using a resolution of: 0.074 ## Added information to colData(CopyKit). The results from findAneuploidCells() are stored within the colData in the column is_aneuploid. We can visualize the results with plotHeatmap(): plotHeatmap(tumor, label = &#39;is_aneuploid&#39;, row_split = &#39;is_aneuploid&#39;, n_threads = 40) ## order_cells argument is NULL. Samples are ordered according to ## colnames(CopyKit) ## Plotting Heatmap. The object is subsetted in the same way as with any R object, to keep only the aneuploid cells. tumor &lt;- tumor[,colData(tumor)$is_aneuploid == TRUE] 5.3 findOutliers() findOutliers() annotates low-quality cells according to a defined resolution threshold. To detect low-quality samples, CopyKit calculates the Pearson correlation matrix of all samples from the segment ratio means. Next, we calculate a sample-wise mean of the correlation between a cell and its k-nearest-neighbors (default = 5). Cells in which the correlation value is lower than the defined threshold are classified as low-quality cells (default = 0.9). tumor &lt;- findOutliers(tumor) ## Calculating correlation matrix. ## Marked 99 cells as outliers. ## Adding information to metadata. Access with colData(scCNA). ## Done. The default correlation cutoff for filtering can be adjusted with the argument ‘resolution’. For example, setting the resolution = 0.8 will mark all cells with a mean correlation smaller than 0.8 as low-quality cells. Higher resolution values will result in stricter filtering criterias. Results from findOutliers() are added to colData (column outlier) marking cells that can be removed or kept. We can check the results with plotHeatmap(). To make visualization easier, rows can also be split according to elements of colData with the argument row_split. plotHeatmap(tumor, label = &#39;outlier&#39;, row_split = &#39;outlier&#39;, n_threads = 40) ## order_cells argument is NULL. Samples are ordered according to ## colnames(CopyKit) ## Plotting Heatmap. We remove the marked low-quality cells from the object with: tumor &lt;- tumor[,colData(tumor)$outlier == FALSE] The dataset should be ready to proceed with the analysis. "],["knn-smoothing.html", "6 kNN smoothing", " 6 kNN smoothing scDNA-Seq experiments are often sparsely sequenced and present inherent noise from low-coverage datasets. To mitigate this, CopyKit is capable of smoothing profiles based on the k-nearest neighbors of each single cell. This way, CopyKit aggregates the genomic bin counts based on a cell k-nearest neighbors, followed by re-segmentation of copy number profiles. In order to ensure optimal performane it is essential to carefully consider the number of neighbors (k) used in the smoothing process. We recommend to use conservative k values, which are below the number of cells that compose the smallest subclone, and to visually inspect and compare smoothed single cells to the original profiles tumor &lt;- knnSmooth(tumor) ## Finding neighbors. ## Smoothing cells using k = 4 ## Running variance stabilization transformation: ft ## Smoothing outlier bins. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. ## Replacing segment_ratios assay. ## Replacing logr assay. ## Done. This step is recommended after the filtering process. Though we have noticed that smoothing can also rescue cells with low-depth quality. If done so, additional inspection is recommended due to the possibility of increased noise. "],["analysis-and-visualization-module.html", "7 Analysis and Visualization module 7.1 plotMetrics() 7.2 plotRatio() 7.3 runUmap() 7.4 scquantum &amp; calcInteger() 7.5 Clustering 7.6 runPca() 7.7 plotHeatmap() 7.8 runPhylo() &amp; plotPhylo() 7.9 calcConsensus() 7.10 plotConsensusLine() 7.11 plotGeneCopy() 7.12 plotFreq() 7.13 plotAlluvial()", " 7 Analysis and Visualization module The analysis and visualization module from CopyKit work in synergy to help you analyze your single cell copy number results. 7.1 plotMetrics() The plotMetrics() function can plot any information store in colData(), which is passed to the metric argument. If a label argument is supplied, the points will be colored based on that information. plotMetrics(tumor, metric = c(&quot;overdispersion&quot;, &quot;breakpoint_count&quot;, &quot;reads_total&quot;, &quot;reads_duplicates&quot;, &quot;reads_assigned_bins&quot;, &quot;percentage_duplicates&quot;), label = &quot;percentage_duplicates&quot;) ## Coloring by: percentage_duplicates 7.2 plotRatio() Visualizing the segmentation to ensure it follows the ratios as expected is crucial to a copy number analysis. This helps to verify the accuracy of the segmentation an assess the quality of the data visually. The plotRatio() function is a useful tool for this, offering two different modes. When the input is the CopyKit object, an interactive app will open, allowing you to choose which cell to visualize from the drop-down option menu. plotRatio(tumor) Ratio Plot App Providing a sample name to the plotRatio() function with the argument sample_name, will display the plot only for the selected cell. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 7.3 runUmap() The runUmap() function generates a UMAP embedding, which is stored in the reducedDim slot. runUmap() is an important pre-processing step for the findClusters() feature. tumor &lt;- runUmap(tumor) ## Using assay: logr ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: reducedDim(scCNA, &#39;umap&#39;). ## Done. You can pass additional arguments to control UMAP parameters using the '...' argument. The full list of additional arguments that can be passed on to uwot::umap with the ‘…’ argument can be found in the uwot manual and information on their influence on clustering can be seen in the UMAP webpage 7.4 scquantum &amp; calcInteger() The scquantum package is integrated into CopyKit to infer absolute copy numbers. It can be used either within CopyKit or as a standalone package available on GitHub. Other methods for inferring absolute copy numbers are metadata and fixed. After running calcInteger(), CopyKit scales the segment ratios to integer values, which are stored in the integer slot and can be accessed using the assay() function. To infer absolute ploidy values using scquantum, specify scquantum as the method argument in calcInteger(). The estimated computational ploidy is stored in colData() along with confidence_ratio, which compares the obtained score with the theoretical estimate, and ploidy_score, a transformation of confidence_ratio with values closer to 0 indicating better ploidy inference calls. We will use the smoothed bincounts from the knnSmooth() step to perform the inference. tumor &lt;- calcInteger(tumor, method = &#39;scquantum&#39;, assay = &#39;smoothed_bincounts&#39;) The resulting ploidy_score scores can be used for further quality control of the single cell dataset. plotMetrics(tumor, metric = &#39;ploidy&#39;, label = &#39;ploidy_score&#39;) ## Coloring by: ploidy_score tumor &lt;- tumor[,colData(tumor)$ploidy_score &lt; 0.2] Setting the method argument to ‘fixed’ scales all cells to a fixed value of ploidy (generally determined by flow cytometry), which is passed to CopyKit using the ploidy_value argument: # NOT RUN tumor &lt;- calcInteger(tumor, method = &#39;fixed&#39;, ploidy_value = 4.3) If the integer assay exists, plotRatio() will plot it as a secondary axis. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 7.5 Clustering The findClusters() function performs clustering using the UMAP embedding generated by runUmap(). For detecting subclones, CopyKit uses different clustering algorithms such as: hdbscan (recommended) Leiden Louvain The hdbscan method is recommended and has been previously successfully applied in the work from Laks et al. and Minussi et al.. 7.5.1 findSugestedK() The findSuggestedK() is a helper function that provides guidance to choose the k parameter for clustering algorithms. The function findSuggestedK bootstraps clustering over a range of k values, and returns the value that maximizes the jaccard similarity, with median as the default metric (argument metric). While findSuggestedK does not guarantee optimal clustering. It provides a guide to select k values. tumor &lt;- findSuggestedK(tumor) ## Calculating jaccard similarity for k range: 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## ## Suggested k = 20 with median jaccard similarity of: 1 The plotSuggestedK() function can be used to inspect the results of findSuggestedK(). It can plot a boxplot, heatmap (tile), or scatterplot plotSuggestedK(tumor) If the argument geom is set to tile, plotSuggestedK() plots a heatmap where each row is a detected subclone, each column is a k assessed during the grid search and the color represents the jaccard similarity for a given clone. The suggested value can be accessed from the metadata: S4Vectors::metadata(tumor)$suggestedK ## [1] 20 7.5.2 findClusters() To run findClusters(), pass the CopyKit object as its input. If findSuggestedK() was run beforehand, findClusters() will automatically use the stored value from findSuggestedK() as the argument for k_subclones, unless otherwise specified. tumor &lt;- findClusters(tumor) ## Using suggested k_subclones = 20 ## Finding clusters, using method: hdbscan ## Found 4 subclones. ## Done. If hdbscan is used for clustering, singletons outliers may be idetified and added to subgroup c0. Copykit will notify you of any cells classified as c0 after running findClusters(). To remove outliers, subset the CopyKit object with: tumor &lt;- tumor[,colData(tumor)$subclones != &#39;c0&#39;] 7.5.3 plotUmap() The plotUmap() function can be used to visualize the reduced dimensional embedding. Points can be colored by any element of the colData with the argument ‘label’. plotUmap(tumor) ## Plotting Umap. plotUmap(tumor, label = &#39;subclones&#39;) ## Plotting Umap. ## Coloring by: subclones. 7.6 runPca() The runPca() function runs a Principal Component Analysis: tumor &lt;- runPca(tumor) ## Using assay: logr ## Embedding data with PCA. ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;pca&#39;). ## Done. The results are stored in the reducedDim(tumor, 'PCA') slot. Principal Components can be used as an alternative pre-processing step to the findClusters() function by changing the findClusters() embedding argument to ‘PCA’ and setting the number of components with ncomponents. However, it’s recommended to use the default UMAP embedding for better results. Visualize the number of useful components with plotScree() and the PCA plot with plotPca() plotPca(tumor, label = &#39;subclones&#39;) ## Plotting PCA. ## Coloring by: subclones. 7.7 plotHeatmap() Copy number profiles can be visualized with a heatmap using the plotHeatmap() function. The elements of colData() can be annotated on the heatmap with the argument label. To order subclones, a consensus phylogeny can be calculated with calcConsensus() and runConsensusPhylo(), if the argument order_cells is not provided, the order of the cells in the heatmap will follow the order of the cells within the CopyKit object. In the plotHeatmap() function, gene annotations can be added with the genes argument. To visualize copy number profiles with a heatmap we can use plotHeatmap(). The heatmap can be annotated with elements of colData. To order subclones, one option is to calculate a consensus phylogeny, explained in later sections: # First we calculate a consensus from the subclones # and a consensus phylogeny tumor &lt;- calcConsensus(tumor) tumor &lt;- runConsensusPhylo(tumor) # We pass &#39;consensus_tree&#39; to plotHeatmap # to order the cells by the stored consensus phylogeny plotHeatmap( tumor, label = &#39;subclones&#39;, genes = c(&quot;TP53&quot;, &quot;BRAF&quot;, &quot;MYC&quot;), order_cells = &#39;consensus_tree&#39; ) ## Ordering cells by:consensus_tree ## Plotting Heatmap. Integer copy number heatmaps can be plotted by passing assay = ‘integer’, with the integer matrix in the ‘integer’ slot. New information can be added to colData() and used in plotting functions. For example, spatial information encoded in the sample name can be extracted and added as a column to the metadata, and used to annotate the heatmap. # adding spatial information colData(tumor)$spatial_info &lt;- stringr::str_extract(colData(tumor)$sample, &quot;L[0-9]&quot;) # plotting the integer heatmap with the spatial and subclonal information plotHeatmap(tumor, assay = &#39;integer&#39;, label = c(&quot;spatial_info&quot;, &quot;subclones&quot;), order_cells = &#39;consensus_tree&#39;) ## Ordering cells by:consensus_tree ## Plotting Heatmap. The spatial information can now also be used to color the elements of the UMAP: plotUmap(tumor, label = &#39;spatial_info&#39;) ## Plotting Umap. ## Coloring by: spatial_info. 7.8 runPhylo() &amp; plotPhylo() The runPhylo() function can be used to perform phylogenetic analysis of cells’ copy number profiles. The available methods are Neighbor Joining and Balanced Minimum evolution.The resulting tree is stored in the phylo slot within the CopyKit object. The plotPhylo() function can be used to visualize the trees generated by runPhylo(). The leaves of the tree can be colored based on any element of the colData by using the argument label. tumor &lt;- runPhylo(tumor, metric = &#39;manhattan&#39;) ## Using ratio data... ## Calculating distance matrix ## Creating neighbor-joining tree. ## Access slot with copykit::phylo(scCNA). ## Done. plotPhylo(tumor, label = &#39;subclones&#39;) ## Warning: The tree contained negative edge lengths. If you want ## to ignore the edges, you can set ## &#39;options(ignore.negative.edge=TRUE)&#39;, then re-run ## ggtree. 7.9 calcConsensus() The calcConsensus() function generates a consensus matrix that can help show the distinct segments among subclones. The function uses subclone information by default, but any colData() element can be used for the calculation. The plotHeatmap() function can be used to plot a consensus heatmap and add metadata information if the label is the same as the one used to build the consensus matrix. The group argument can be passed to add additional annotation from colData() in the format of a frequency barplot. tumor &lt;- calcConsensus(tumor) # We use the plotHeatmap function to plot the # consensus matrix by passing the argument `consensus`. plotHeatmap(tumor, consensus = TRUE, label = &#39;subclones&#39;, group = &#39;spatial_info&#39;) ## order_cells argument is NULL. Samples are ordered according to ## colnames(CopyKit) ## Plotting Heatmap. To calculate consensus from the integer assay, set the calcConsensus() argument assay to ‘integer’ and plot it with plotHeatmap() tumor &lt;- calcConsensus(tumor, consensus_by = &#39;subclones&#39;, assay = &#39;integer&#39;) plotHeatmap(tumor, consensus = TRUE, assay = &#39;integer&#39;, label = &#39;subclones&#39;, group = &#39;spatial_info&#39;) ## order_cells argument is NULL. Samples are ordered according to ## colnames(CopyKit) ## Plotting Heatmap. 7.10 plotConsensusLine() To compare the differences among subclones, plotConsensusLine() opens an interactive app where the consensus sequences are plotted as lines. plotConsensusLine(tumor) Plot Consensus Line 7.11 plotGeneCopy() The plotGeneCopy() function can be used to view copy number states for genes. Two different geoms are available: “swarm” (default) or “violin”. Points can be colored using the ‘label’ argument. To visualize across groups, a positional dodge can be added. Example: plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), label = &#39;subclones&#39;, dodge.width = 0.8) ## Coloring by: subclones A barplot geom can be used to visualize the integer data as a frequency barplot for each gene: plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), geom = &#39;barplot&#39;, assay = &#39;integer&#39;) 7.12 plotFreq() The plotFreq() function can be used to visualize genomic gains or losses across the genome. This function calculates the frequency of gain or losses in each region of the genome based on a threshold applied to all samples. The low_threshold argument (below which values are counted as genomic losses) and high_threshold argument (above which values are counted as genomic gains) control the thresholds. It is recommended to set the thresholds based on the ploidy of the sample. To use the integer assay instead of the default segment_ratios assay, pass the assay argument. The visual representation of the frequencies can be shown as either an area or a line geom plotFreq(tumor) Elements of colData() can be used to split the plot across different groups. plotFreq(tumor, group = &#39;subclones&#39;) 7.13 plotAlluvial() To visualize frequencies across elements of the metadata we can use plotAlluvial() plotAlluvial(tumor, label = c(&quot;subclones&quot;, &quot;spatial_info&quot;)) "],["merging-copykit-objects.html", "8 Merging CopyKit Objects", " 8 Merging CopyKit Objects CopyKit objects can be merged into one object with the cbind() function. Example: # gain of chromosome 7 and deletion of chromosome 10 ck1 &lt;- mock_bincounts( ncells = 50, ncells_diploid = 0, position_gain = 4900:5493, position_del = 6523:7056, genome = &quot;hg38&quot;, resolution = &quot;220kb&quot; ) ## Running variance stabilization transformation: ft ## Smoothing outlier bins. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. # adding an identifier to colData colData(ck1)$info &lt;- &#39;object1&#39; # gain of chromosome 7 and deletion of chromosome 10 # additional gain of chromosome 1 ck2 &lt;- mock_bincounts( ncells = 50, ncells_diploid = 0, position_gain = c(1:906, 4900:5493), position_del = 6523:7056, genome = &quot;hg38&quot;, resolution = &quot;220kb&quot; ) ## Running variance stabilization transformation: ft ## Smoothing outlier bins. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. # adding an identifier to colData colData(ck2)$info &lt;- &#39;object2&#39; # merging objects merged_copykit &lt;- cbind(ck1, ck2) Following merge a standard CopyKit analysis can be applied # UMAP and clustering merged_copykit &lt;- runUmap(merged_copykit) ## Using assay: logr ## Embedding data with UMAP. Using seed 17 ## Warning in .check_reddim_names(x, value, withDimnames): non-NULL &#39;rownames(value)&#39; should be the same as ## &#39;colnames(x)&#39; for &#39;reducedDim&lt;-&#39;. This will be an ## error in the next release of Bioconductor. ## Access reduced dimensions slot with: reducedDim(scCNA, &#39;umap&#39;). ## Done. merged_copykit &lt;- findSuggestedK(merged_copykit) ## Calculating jaccard similarity for k range: 10 ## ## Suggested k = 10 with median jaccard similarity of: 1 merged_copykit &lt;- findClusters(merged_copykit) ## Using suggested k_subclones = 10 ## Finding clusters, using method: hdbscan ## Found 2 subclones. ## Done. plotUmap(merged_copykit, label = &#39;subclones&#39;) ## Plotting Umap. ## Coloring by: subclones. # plotting plotHeatmap(merged_copykit, label = &#39;info&#39;, order_cells = &#39;hclust&#39;) ## Ordering cells by:hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 1 cores. ## Access distance matrix with copykit::distMat() ## Done. ## Plotting Heatmap. "],["session-info.html", "9 Session Info", " 9 Session Info sessionInfo() ## R version 4.2.0 (2022-04-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/liblapack.so.3 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils ## [6] datasets methods base ## ## other attached packages: ## [1] BiocParallel_1.30.2 ## [2] copykit_0.1.2 ## [3] DNAcopy_1.70.0 ## [4] Rsubread_2.10.0 ## [5] SingleCellExperiment_1.18.0 ## [6] SummarizedExperiment_1.26.1 ## [7] Biobase_2.56.0 ## [8] GenomicRanges_1.48.0 ## [9] GenomeInfoDb_1.32.2 ## [10] IRanges_2.30.0 ## [11] S4Vectors_0.34.0 ## [12] BiocGenerics_0.42.0 ## [13] MatrixGenerics_1.8.0 ## [14] matrixStats_0.62.0 ## ## loaded via a namespace (and not attached): ## [1] rappdirs_0.3.3 rtracklayer_1.56.0 ## [3] prabclus_2.3-2 coda_0.19-4 ## [5] tidyr_1.2.0 ggplot2_3.3.6 ## [7] clusterGeneration_1.3.7 bit64_4.0.5 ## [9] knitr_1.39 irlba_2.3.5 ## [11] DelayedArray_0.22.0 KEGGREST_1.36.0 ## [13] RCurl_1.98-1.6 doParallel_1.0.17 ## [15] generics_0.1.2 GenomicFeatures_1.48.1 ## [17] ScaledMatrix_1.4.0 cowplot_1.1.1 ## [19] RSQLite_2.2.14 combinat_0.0-8 ## [21] bit_4.0.4 xml2_1.3.3 ## [23] lubridate_1.8.0 httpuv_1.6.5 ## [25] assertthat_0.2.1 viridis_0.6.2 ## [27] amap_0.8-18 xfun_0.31 ## [29] jquerylib_0.1.4 hms_1.1.1 ## [31] ggdist_3.1.1 evaluate_0.15 ## [33] promises_1.2.0.1 DEoptimR_1.0-11 ## [35] fansi_1.0.3 restfulr_0.0.13 ## [37] progress_1.2.2 dbplyr_2.1.1 ## [39] igraph_1.3.1 DBI_1.1.2 ## [41] tmvnsim_1.0-2 paletteer_1.4.0 ## [43] purrr_0.3.4 ellipsis_0.3.2 ## [45] dplyr_1.0.9 ggnewscale_0.4.7 ## [47] backports_1.4.1 bookdown_0.26 ## [49] biomaRt_2.52.0 sparseMatrixStats_1.8.0 ## [51] vctrs_0.4.1 ggalluvial_0.12.3 ## [53] Cairo_1.5-15 abind_1.4-5 ## [55] withr_2.5.0 cachem_1.0.6 ## [57] robustbase_0.95-0 GenomicAlignments_1.32.0 ## [59] treeio_1.20.0 prettyunits_1.1.1 ## [61] scran_1.24.0 mclust_5.4.9 ## [63] mnormt_2.0.2 phytools_1.0-3 ## [65] cluster_2.1.3 segmented_1.5-0 ## [67] ape_5.6-2 lazyeval_0.2.2 ## [69] crayon_1.5.1 labeling_0.4.2 ## [71] edgeR_3.38.1 pkgconfig_2.0.3 ## [73] vipor_0.4.5 nlme_3.1-157 ## [75] nnet_7.3-17 pals_1.7 ## [77] rlang_1.0.2 diptest_0.76-0 ## [79] miniUI_0.1.1.1 lifecycle_1.0.1 ## [81] filelock_1.0.2 dbscan_1.1-10 ## [83] BiocFileCache_2.4.0 rsvd_1.0.5 ## [85] dichromat_2.0-0.1 distributional_0.3.0 ## [87] Matrix_1.5-3 aplot_0.1.4 ## [89] phangorn_2.8.1 carData_3.0-5 ## [91] boot_1.3-28 beeswarm_0.4.0 ## [93] GlobalOptions_0.1.2 viridisLite_0.4.0 ## [95] png_0.1-7 rjson_0.2.21 ## [97] bitops_1.0-7 Biostrings_2.64.0 ## [99] blob_1.2.3 DelayedMatrixStats_1.18.0 ## [101] shape_1.4.6 stringr_1.4.0 ## [103] rstatix_0.7.0 gridGraphics_0.5-1 ## [105] beachmat_2.12.0 scales_1.2.0 ## [107] memoise_2.0.1 magrittr_2.0.3 ## [109] zlibbioc_1.42.0 compiler_4.2.0 ## [111] dqrng_0.3.0 BiocIO_1.6.0 ## [113] RColorBrewer_1.1-3 plotrix_3.8-2 ## [115] clue_0.3-60 Rsamtools_2.12.0 ## [117] snakecase_0.11.0 cli_3.3.0 ## [119] XVector_0.36.0 patchwork_1.1.1 ## [121] MASS_7.3-57 tidyselect_1.1.2 ## [123] stringi_1.7.6 forcats_0.5.1 ## [125] highr_0.9 purler_0.1.1 ## [127] yaml_2.3.5 BiocSingular_1.12.0 ## [129] locfit_1.5-9.5 grid_4.2.0 ## [131] sass_0.4.1 fastmatch_1.1-3 ## [133] tools_4.2.0 parallel_4.2.0 ## [135] circlize_0.4.15 rstudioapi_0.13 ## [137] bluster_1.6.0 foreach_1.5.2 ## [139] gridExtra_2.3 janitor_2.1.0 ## [141] metapod_1.4.0 scatterplot3d_0.3-41 ## [143] farver_2.1.0 digest_0.6.29 ## [145] FNN_1.1.3 shiny_1.7.1 ## [147] quadprog_1.5-8 fpc_2.2-9 ## [149] Rcpp_1.0.8.3 car_3.0-13 ## [151] broom_0.8.0 scuttle_1.6.2 ## [153] later_1.3.0 httr_1.4.3 ## [155] AnnotationDbi_1.58.0 ComplexHeatmap_2.12.0 ## [157] kernlab_0.9-30 colorspace_2.0-3 ## [159] XML_3.99-0.9 reticulate_1.25 ## [161] splines_4.2.0 uwot_0.1.11 ## [163] yulab.utils_0.0.4 statmod_1.4.36 ## [165] rematch2_2.1.2 tidytree_0.3.9 ## [167] expm_0.999-6 mapproj_1.2.8 ## [169] ggplotify_0.1.0 flexmix_2.3-17 ## [171] xtable_1.8-4 jsonlite_1.8.0 ## [173] ggtree_3.4.0 modeltools_0.2-23 ## [175] ggfun_0.0.6 R6_2.5.1 ## [177] pillar_1.7.0 htmltools_0.5.2 ## [179] mime_0.12 glue_1.6.2 ## [181] fastmap_1.1.0 BiocNeighbors_1.14.0 ## [183] class_7.3-20 codetools_0.2-18 ## [185] maps_3.4.0 utf8_1.2.2 ## [187] bslib_0.3.1 lattice_0.20-45 ## [189] tibble_3.1.7 mixtools_1.2.0 ## [191] numDeriv_2016.8-1.1 ggbeeswarm_0.6.0 ## [193] scquantum_1.0.0 curl_4.3.2 ## [195] leiden_0.4.2 gtools_3.9.2 ## [197] magick_2.7.3 survival_3.3-1 ## [199] limma_3.52.1 rmarkdown_2.14 ## [201] munsell_0.5.0 GetoptLong_1.0.5 ## [203] fastcluster_1.2.3 GenomeInfoDbData_1.2.8 ## [205] iterators_1.0.14 gtable_0.3.0 "],["faq.html", "10 FAQ 10.1 Error unable to load package after installation. 10.2 CopyKit is very slow despite parallel processing", " 10 FAQ 10.1 Error unable to load package after installation. This error is generally related to the ComplexHeatmap dependency, used by heatmap functions in CopyKit and it has been reported in MacOS devices. The following are instructions to install Cairo. You might need to install the following: Xquartz - https://www.xquartz.org/ In R: install.packages(&quot;Cairo&quot;, dependencies=TRUE) For additional information check this github thread 10.2 CopyKit is very slow despite parallel processing This issue has been generally associated with running and registering CopyKit parallel functions within Rmarkdown files (.Rmd) or R notebook files. We recommend running CopyKit functions within R scripts (.R) "],["learn-more.html", "11 Learn more 11.1 Copy Number data from short reads sequencing 11.2 Principle 11.3 VarBin 11.4 GC correction 11.5 Merge Levels 11.6 How do we infer copy numbers 11.7 Segmentation", " 11 Learn more This section is always expanding. If you have a contribution and would like to add explanations for a method related to copy number data, please submit a PR. Contributions are extremely welcomed! 11.1 Copy Number data from short reads sequencing 11.2 Principle To infer copy number data from short-read sequencing we count the number of reads that align to a particular region of the genome. Counter intuitively, we are not drawn to the individual nucleotides, but the regions of the genome in which the reads have aligned. 11.3 VarBin To perform the alignment of millions of reads in a reasonable time frame, aligners trade-off accuracy for speed. Furthermore, the genome is filled with repetitive and hard to map regions. As a consequence, errors produced during the process of alignment are known as mapping errors. Mapping errors may be a significant source of bias. Correct estimation of copy number gains or losses is dependent on accurate control of different biases. To infer copy number variations and account for sources of bias, different methods have been developed, including the Variable Binning method. The VarBin method accounts for mapping bias by partitioning the genome into bins of variable sizes. The guiding principle is, if we were to map a diploid genome to our scaffold, each bin will receive an equal number of reads. To construct the VarBin scaffolds, reads are simulated from a reference genome and mapped back. The reference genome is partitioned into bins of variable sizes, that receive an equal amount of reads. We can construct scaffolds of different resolutions. Higher resolutions will have smaller bin sizes and detect more ‘focal’ copy number events. The decision of which resolution to use is dependent on diverse factors. Those include the library complexity, number of multiplexed cells, sequencer output, among others. Generally, a target of 1M reads/cell, with a 10% PCR duplicate rate, is sufficient to generate high-quality copy number profiles for the 220kb scaffold. 11.4 GC correction GC-content can be a source of bias within the counts. Normalization of GC content is performed as follows: Both fragment counts and GC counts are binned to a bin-size of choice. A curve describing the conditional mean fragment count per GC value is estimated. The resulting GC curve determines a predicted count for each bin based on the bin’s GC. These predictions can be used directly to normalize the original signal, or as the rates for a heterogeneous Poisson model. Extracted from: Summarizing and correcting the GC content bias in high-throughput sequencing. Benjamini &amp; Speed Therefore, we smooth the signal using loess normalization. 11.5 Merge Levels After segmentation, some segments remain with small differences, generating spurious breakpoints that are unlikely to be real copy number events. To remove this effect we perform a Wilcoxon rank-sum test between the observed median across two segments. Segments that do not reach significance are merged. 11.6 How do we infer copy numbers We previously partitioned the reference genome into bins of variables size and performed the alignment of the reads to the bins, quantifying the number of reads contained in each bin. We can infer the relative copy number of a sample relative to the average number of reads of the sample. Therefore, we perform a sample-wise normalization of the bin counts by their mean. This way, a value of 1 corresponds to the average copy number of the sample, whereas higher values reflect amplified regions, and lower values represent genomic losses. The resulting matrix is known as the ratio matrix and it’s segmented counterpart is known as the segment ratios mean matrix. Importantly, with this normalization, we can’t immediately determine the integer copy number of a given segment. However several methods have been developed to infer the ploidy of a cell and its segments using short read sequencing. 11.7 Segmentation 11.7.1 CBS Circular Binary Segmentation (CBS) is a popular method of segmentation. From the help of DNAcopy package (see ?DNAcopy::segment): This function implements the circular binary segmentation (CBS) algorithm of Olshen and Venkatraman (2004). Given a set of genomic data, either continuous or binary, the algorithm recursively splits chromosomes into either two or three subsegments based on a maximum t-statistic. A reference distribution, used to decided whether or not to split, is estimated by permutation. Options are given to eliminate splits when the means of adjacent segments are not sufficiently far apart. Note that after the first split the α-levels of the tests for splitting are not unconditional. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
