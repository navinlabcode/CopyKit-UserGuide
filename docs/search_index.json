[["index.html", "CopyKit User Guide 1 Introduction", " CopyKit User Guide Darlan Conterno Minussi Last revised: 2021-09-05 1 Introduction This is the user guide for the CopyKit package. CopyKit is a toolkit for single-cell analysis of copy number datasets. Copykit expands from the existing robust scaffold for single-cell analysis provided by the Bioconductor packages SingleCellExperiment and SummarizedExperiment and, provides the tools to perform binning of sequencing reads, segmentation as well as quality control and downstream analysis of scDNA-Seq datasets. CopyKit uses the Variable Binning (Baslan et al. 2012; Gao et al. 2016) pipeline to process datasets. All the information from a scDNA-Seq dataset is stored within the scCNA object for downstream analysis. CopyKit functions can be split into 4 modules: 1) Pre-processing, 2) Quality Control, 3) Analysis and, 4) Visualization module. The next chapters of this user guide will cover each module in detail. This documentation was generated with CopyKit version: packageVersion(&quot;copykit&quot;) ## [1] &#39;0.0.0.9025&#39; "],["parallelization.html", "2 Parallelization", " 2 Parallelization For all parallel calculations, CopyKit adopts the BiocParallel framework. Make sure to read the BiocParallel vignette to choose the best parameters for your machine. An example workflow can be done as follows: We use BiocParallel::register() function to register the number of workers desired. library(BiocParallel) register(MulticoreParam(progressbar = T), default = T) The default parameter can be confirmed with: BiocParallel::bpparam() ## class: MulticoreParam ## bpisup: FALSE; bpnworkers: 124; bptasks: 0; bpjobname: BPJOB ## bplog: FALSE; bpthreshold: INFO; bpstopOnError: TRUE ## bpRNGseed: ; bptimeout: 2592000; bpprogressbar: FALSE ## bpexportglobals: TRUE ## bplogdir: NA ## bpresultdir: NA ## cluster type: FORK Make sure to check the number of workers in use. The higher the number of workers available the faster CopyKit computations will perform. The argument progressbar allows for a helpful progression bar while the process is being run. After this setup CopyKit parallelized functions will automatically recognize these parameters and run in parallel. Running parallel process is highly recommended to speed up CopyKit calculations. "],["quick-start.html", "3 Quick-Start", " 3 Quick-Start This section provides a basic workflow with CopyKit. Detailed description of CopyKit functions is provided in the following sections. # Run pre-processing module tumor &lt;- runVarbin(&quot;/path/to/marked/bam/files/&quot;, remove_Y = TRUE) # Mark normal cells if they exist tumor &lt;- findNormalCells(tumor) # Filter cells tumor &lt;- filterCells(tumor) # Visualize the result from filtering and cells marked as diploid plotHeatmap(tumor, label = c(&#39;filtered&#39;, &#39;is_normal&#39;), row_split = &#39;filtered&#39;) # Remove cells marked as normal or noise cells from the copykit object tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$filtered == &quot;kept&quot;] tumor &lt;- tumor[,SummarizedExperiment::colData(tumor)$is_normal == FALSE] # Create a umap embedding tumor &lt;- runUmap(tumor) # Search for the best K value for clustering of subclones # according to jaccard similarity and plot the results tumor &lt;- findSuggestedK(tumor) plotSuggestedK(tumor) # Find clusters and plot the results tumor &lt;- findClusters(tumor) plotUmap(tumor, label = &#39;subclones&#39;) # Plot a Copy Number Heatmap with clustering annotation plotHeatmap(tumor, label = &#39;subclones&#39;) "],["pre-processing.html", "4 Pre-processing 4.1 runVarbin()", " 4 Pre-processing CopyKit pre-processing module consists of 1 function that performs 3 main processes: Counts reads from the from the .bam files Applies a variance stabilization transformation to the dataset Segments the data into piece-wise constant function for inference of copy number states 4.1 runVarbin() First we load CopyKit with the library() function library(copykit) NOTE: CopyKit functions will automatically run in parallel if the BiocParallel framework was registered. For more information check section 2. runVarbin() accepts duplicates marked .bam files as input and performs the binning of reads into bins according to the variable binning pipeline (Baslan et al. 2012; Gao et al. 2016). To help users obtain these processed files from .fastq files a snakemake pipeline is available here that uses bowtie2 for the alignment of reads and sambamba for the removal of pcr duplicates. This pipeline can be adapted as per users’ needs and the only requirement for CopyKit is the use of .bam files as the input. runVarbin() the first argument should be the path to the .bam files location. tumor &lt;- runVarbin(&quot;~/path/to/bam/files/&quot;, remove_Y = TRUE) ## Counting reads. ## 34 bam files had less than 10 mean bincounts and were removed. ## Performing GC correction. ## Smoothing bin counts. ## Running segmentation algorithm: CBS for genome hg38 ## Merging levels. ## Done. runVarbin() by default uses a varbin pipeline scaffold for the genome hg38 with a resolution of bins with an average size of 200kb. Both options can be changed with the arguments genome or resolution. For samples that are XX, runVarbin() can be set to ignore any read that may have aligned to chrY with the argument remove_Y = TRUE. A consequence of the count nature of copy-number sequencing data is a negative binomial distribution with overdispersion at higher counts. To account for that CopyKit offers a variance stabilization transformation procedure with the function runVst(). By default, CopyKit will apply the freeman-tukey transformation to the bin count dataset. The resulting object is the CopyKit object of class scCNA that can be inspected. tumor ## class: scCNA ## dim: 11732 1502 ## metadata(2): genome vst ## assays(6): segment_ratios ratios ... smoothed_bincounts logr ## rownames(11732): 1 2 ... 11731 11732 ## rowData names(3): gc_content abspos arm ## colnames(1502): PMTC6LiverC100DL1S2_S100_L001_R1_001 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 ... PMTC6LiverC9DL1S5_S393_L002_R1_001 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 ## colData names(9): sample reads_assigned_bins ... reads_total percentage_duplicates ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowRanges has: 11732 ranges ## Phylo: Phylogenetic tree with 0 tips and nodes ## consensus dim: 0 0 CopyKit objects expand on the SingleCellExperiment class where each column represents a single-cell and each row represents a bin. The information of the bincounts resulting from runVarbin() are stored withing the bin_counts slot that can be acessed with the bin_counts() accessor. (Here displaying the first five columns). head(bin_counts(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 37.04614 10.395168 ## 2 28.80244 12.965916 ## 3 38.91312 19.446782 ## 4 34.68326 9.012024 ## 5 24.21541 14.321900 ## 6 30.73573 9.293686 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 45.03621 44.96082 ## 2 53.35382 52.56741 ## 3 68.39362 47.09604 ## 4 50.15488 47.09568 ## 5 34.89452 35.74422 ## 6 56.32697 37.68537 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 40.51292 ## 2 32.57882 ## 3 57.68050 ## 4 31.94578 ## 5 37.85281 ## 6 30.51317 Classically copy number data has been transformed with a logarithm transformation, the log transformation can be set within CopyKit with the argument runVst(copykit_object, transformation = 'log). Warning The segmentation step (see next section) can be very slow when transformation = ‘log’ is selected. Even though the process is fast for most cells it can hang in a few cells with large breakpoint numbers and take ~ 1hr to complete. The resulting transformation is stored within the CopyKit object in the ft slot if freeman-tukey was performed and can be accessed with the assay() function: head(assay(tumor, &#39;ft&#39;)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 12.254709 6.599827 ## 2 10.825951 7.337922 ## 3 12.555721 8.931662 ## 4 11.862796 6.166181 ## 5 9.942409 7.698748 ## 6 11.177428 6.256932 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 13.49590 13.48472 ## 2 14.67687 14.56931 ## 3 16.60033 13.79779 ## 4 14.23428 13.79773 ## 5 11.89836 12.04035 ## 6 15.07659 12.35860 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 12.80803 ## 2 11.50251 ## 3 15.25509 ## 4 11.39190 ## 5 12.38567 ## 6 11.13753 Lastly segmentation fits piece-wise constant functions to every profile generating segment means that can be used to infer copy-number states across every cell. Segmentation method is chosen by passing the argument method to runVarbin() with the desired option. Current available segmentation methods are: 4.1.1 CBS {DNACopy} By default, CopyKit applies Circular Binary Segmentation (CBS) from the DNAcopy package to perform segmentation of each chromosome arm. The penalty of the segmentation is controlled by the argument alpha that can be passed on to runVarbin() 4.1.2 multipcf {copynumber} A second segmentation option is using the multipcf segmentation from the package copynumber. multipcf differs from CBS by performing a joint segmentation of the samples, resulting in common break points to all samples. The resulting information from runSegmentation() is stored within the CopyKit object into two different assays: ratios and segment_ratios, which can be accessed with the helper function ratios() and segment_ratios() head(ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 1.1425154 0.9138493 ## 2 0.8882768 1.1398463 ## 3 1.2000936 1.7095855 ## 4 1.0696433 0.7922557 ## 5 0.7468112 1.2590521 ## 6 0.9479001 0.8170169 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 0.9467375 1.0779109 ## 2 1.1215877 1.2602748 ## 3 1.4377497 1.1291016 ## 4 1.0543406 1.1290932 ## 5 0.7335418 0.8569480 ## 6 1.1840883 0.9034862 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 1.0803402 ## 2 0.8687651 ## 3 1.5381405 ## 4 0.8518842 ## 5 1.0094041 ## 6 0.8136814 head(segment_ratios(tumor)[,1:5]) ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S6_S484_L002_R1_001 ## 1 1 0.9880972 ## 2 1 0.9880972 ## 3 1 0.9880972 ## 4 1 0.9880972 ## 5 1 0.9880972 ## 6 1 0.9880972 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 ## 1 1 1.028186 ## 2 1 1.028186 ## 3 1 1.028186 ## 4 1 1.028186 ## 5 1 1.028186 ## 6 1 1.028186 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 ## 1 0.9955956 ## 2 0.9955956 ## 3 0.9955956 ## 4 0.9955956 ## 5 0.9955956 ## 6 0.9955956 From now on, the derived segment ratios will be the main type of data where the copy number analysis will be performed. "],["qc-module.html", "5 QC module 5.1 runMetrics() 5.2 findNormalCells() 5.3 filterCells()", " 5 QC module CopyKit QC Module consists of 3 main functions: 1) runMetrics(), 2) filterCells() and 3) findNormalCells(). 5.1 runMetrics() runMetrics() is used to add basic quality control information to the metadata of the CopyKit object. It will return information on the overdispersion on the datasets and the number of breakpoints for each single-cell. tumor &lt;- runMetrics(tumor) ## Calculating overdispersion. ## Counting breakpoints. ## Done. The resulting information can be seen at the metadata with: colData(tumor) ## DataFrame with 1502 rows and 11 columns ## sample reads_assigned_bins ## &lt;character&gt; &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 PMTC6LiverC100DL1S2_.. 380341 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 PMTC6LiverC100DL1S6_.. 136595 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 PMTC6LiverC100DL4L5S.. 562352 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 PMTC6LiverC100DL6L7S.. 490167 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 PMTC6LiverC101DL1S2_.. 444286 ## ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 PMTC6LiverC99DL4L5S1.. 482575 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 PMTC6LiverC99DL6L7S3.. 321040 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 PMTC6LiverC9DL1S1_S9.. 287250 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 PMTC6LiverC9DL1S5_S3.. 487006 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 PMTC6LiverC9DL6L7S1_.. 352447 ## reads_unmapped reads_duplicates reads_multimapped ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 30250 34883 0 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 22260 12657 0 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 30942 58222 0 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 28239 53055 0 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 28756 43008 0 ## ... ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 37945 54159 0 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 28090 36534 0 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 38326 25527 0 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 34111 48055 0 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 38814 37898 0 ## reads_unassigned reads_ambiguous reads_total ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 57879 90 503443 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 22623 30 194165 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 84002 118 735636 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 75387 99 646947 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 67149 81 583280 ## ... ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 74653 91 649423 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 50306 62 436032 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 46259 54 397416 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 74120 110 643402 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 56100 70 485329 ## percentage_duplicates overdispersion ## &lt;numeric&gt; &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0.069 0.00383136 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 0.065 0.01614355 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0.079 0.00399620 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0.082 0.00456572 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 0.074 0.00742928 ## ... ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 0.083 0.00288895 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0.084 0.00479170 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 0.064 0.00667991 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0.075 0.00337467 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 0.078 0.00371427 ## breakpoint_count ## &lt;numeric&gt; ## PMTC6LiverC100DL1S2_S100_L001_R1_001 0 ## PMTC6LiverC100DL1S6_S484_L002_R1_001 3 ## PMTC6LiverC100DL4L5S1_S868_L003_R1_001 0 ## PMTC6LiverC100DL6L7S3_S1252_L004_R1_001 0 ## PMTC6LiverC101DL1S2_S101_L001_R1_001 6 ## ... ... ## PMTC6LiverC99DL4L5S1_S867_L003_R1_001 3 ## PMTC6LiverC99DL6L7S3_S1251_L004_R1_001 0 ## PMTC6LiverC9DL1S1_S9_L001_R1_001 3 ## PMTC6LiverC9DL1S5_S393_L002_R1_001 0 ## PMTC6LiverC9DL6L7S1_S1161_L004_R1_001 5 5.2 findNormalCells() It is common for datasets to contain normal cells with flat profiles mixed in with the aneuploidy cells from a tumor that is being profiled. findNormalCells() performs a sample-wise calculation of the segment ratios coefficient of variation. By default findNormalCells() tries to automatically identify the resolution threshold by fitting a normal mixture model to the distribution of coefficient of variation from all samples. To increase the sensitivity of the model, findNormalCells also simulate the expected coefficient of variation. Lastly, findNormalCells() add the resulting information to the metadata of the CopyKit object in a column named ‘is_normal.’ tumor &lt;- findNormalCells(tumor) ## number of iterations= 41 ## Copykit detected 620 that are possibly normal cells using a resolution of: 0.088 ## Done. Information was added to metadata column &#39;is_normal&#39;. plotHeatmap() can again be used to visualize the results from findNormalCells() plotHeatmap(tumor, label = &#39;is_normal&#39;, row_split = &#39;is_normal&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. ## Plotting Heatmap. The object can be subsetted in the same way as any R object is subsetted. tumor &lt;- tumor[,colData(tumor)$is_normal == FALSE] 5.3 filterCells() filterCells() removes low-quality cells according to a defined resolution threshold. Cells with correlation smaller than the mean of its k-nearest neighbors are defined as noisy samples and this information, as well as the correlation value, is added to the scCNA object metadata. tumor &lt;- filterCells(tumor) ## Calculating correlation matrix. ## Marked 88 cells to be removed. ## Adding information to metadata. Access with colData(scCNA). ## Done. The default resolution threshold is 0.9 and it can be adjusted accordingly to user needs with the argument ‘resolution.’ filterCells() adds a column to the metadata called ‘filtered’ marking cells that should be removed or kept. After filtering the function plotHeatmap() from the visualization module can be used to visualize the results from filterCells() with the argument label set to ‘filtered.’ To make visualization easier, rows can also be split according to elements of the metadata with the argument row_split. plotHeatmap(tumor, label = &#39;filtered&#39;, row_split = &#39;filtered&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. ## Plotting Heatmap. If satisfied with the filtering results we remove the noise cells from the object. tumor &lt;- tumor[,colData(tumor)$filtered == &#39;kept&#39;] Your dataset should be ready to proceed with the analysis. "],["analysis-and-visualization-module.html", "6 Analysis and Visualization module 6.1 plotMetrics() 6.2 plotRatio() 6.3 runUmap() 6.4 plotUmap() 6.5 Clustering 6.6 runPhylo() 6.7 plotPhylo() 6.8 calcInteger() 6.9 plotHeatmap() 6.10 plotFreq() 6.11 calcConsensus() 6.12 plotConsensusLine() 6.13 findVariableGenes() 6.14 plotVariableGenes() 6.15 plotGeneCopy()", " 6 Analysis and Visualization module The analysis and visualization module from CopyKit work in synergy to help you analyze and assess the results from your day. The analysis module provides the following functions: runUmap(), calcInteger(), findSuggestedK(), findClusters(), calcConsensus() and runPhylo(). The visualization module functions are: plotMetrics(), plotRatio(), plotUmap(), plotHeatmap(), plotConsensusLine() and plotGeneCopy(). 6.1 plotMetrics() plotMetrics() can be used to plot any information available in the `colData(). As a reminder, we can check the elements within coldata() with: names(colData(tumor)) ## [1] &quot;sample&quot; &quot;reads_assigned_bins&quot; &quot;reads_unmapped&quot; ## [4] &quot;reads_duplicates&quot; &quot;reads_multimapped&quot; &quot;reads_unassigned&quot; ## [7] &quot;reads_ambiguous&quot; &quot;reads_total&quot; &quot;percentage_duplicates&quot; ## [10] &quot;overdispersion&quot; &quot;breakpoint_count&quot; &quot;is_normal&quot; ## [13] &quot;find_normal_cv&quot; &quot;filter_corr_value&quot; &quot;filtered&quot; plotMetrics() argument metric defines which information to plot. whereas the argument label, if supplied, will color the plot based on that information. plotMetrics(tumor, metric = c(&quot;overdispersion&quot;, &quot;breakpoint_count&quot;, &quot;reads_total&quot;, &quot;reads_duplicates&quot;, &quot;reads_assigned_bins&quot;, &quot;percentage_duplicates&quot;), label = &quot;overdispersion&quot;) ## Coloring by: overdispersion 6.2 plotRatio() It is often important to visualize that the segmentation behaved as expected and closely follows the ratios. Not missing important events. Ratio plots are a great tool for this. You can plot ratio plots with the plotRatio() function. plotRatio() has two different modes. When the input is the CopyKit object an interactive app will run and you can select which cell will be visualized. plotRatio(tumor) If plotRatio() is given a sample name only the plot for that cell will be shown. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 6.3 runUmap() runUmap uses generates a UMAP reduced dimensions embedding, the resulting embedding is stored within the scCNA reducedDim slot and is an important pre-processing step to the findClusters feature. tumor &lt;- runUmap(tumor) ## Using assay: logr ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;umap&#39;). ## Done. Additional arguments to control umap parameters can be passed on torunUmap() with the ‘…’ argument. As exemplified in the code below. By default, CopyKit will pass to the umap different values of n_neighbor and min_dist using: n_neighbor = 30 and min_dist = 0. The full list of additional arguments that can be passed on to uwot::umap with the ‘…’ argument to runUmap() can be seen in the uwot manual. tumor &lt;- runUmap(tumor, n_neighbors = 30, min_dist = 0) ## Using assay: logr ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;umap&#39;). ## Done. 6.4 plotUmap() plotUmap() can be used to plot the reduced dimensional embedding. plotUmap can be colored by any element of the metadata with the argument ‘label,’ this will be shown in a later section. plotUmap(tumor) ## Plotting Umap. 6.5 Clustering findClusters uses the reduced dimensional embedding resulting from runUmap() to perform clustering at two levels, hereby referred to as superclones and subclones. When clustering for superclones, findClusters() creates a graph representation of the reduced dimension embedding using a shared nearest neighbor algorithm (SNN), from this graph the connected components are extracted and generally represent high-level structures that share large, lineage defining copy number events. At a more fine-grained resolution, CopyKit can also be used to detect subclones, i. e. groups of cells containing more exclusive copy number event per cluster. To do so, the umap embedding is again used as the pre-processing step, this time to perform a density-based clustering with hdbscan hdbscan. The findClusters() function will use the reduced dimensional embedding resulting from runUmap() to perform clustering of superclones and subclones. When clustering for superclones findClusters() creates a graph representation of the dataset reduced dimension embedding using a shared nearest neighbor algorithm (SNN), from this graph the connected components are extracted and generally represent high-level structures that share large, lineage defining copy number events. CopyKit can also be used to detect subclones, i. e. groups of cells containing a unique copy number event per cluster, to do so the umap embedding is again used as the pre-processing step, this time to perform a density-based clustering with hdbscan previously applied in different copy number analysis, as seen, in the work from Laks et al. (RN6?). Network clustering algorithms can also be used to detect subclones. By setting the argument method to leiden CopyKit will again use the SNN representation of the reduced dimensional embedding to apply the graph based clustering. 6.5.1 findSugestedK() Density-based clustering requires the input of the k neighbors, frequently chosen ad hoc. To help with parametrization, CopyKit provides the helper findSuggestedK function. findSuggestedK performs a clustering bootstrapping over a range of k values and returns the value that maximizes the jaccard similarity, by default the metric being maximized is mean, however, it is also possible to maximize the median with the argument metric. While findSuggestedK does not guarantee that the suggested value will result in optimal clustering but provides a guide that maximizes cluster stability. tumor &lt;- findSuggestedK(tumor) ## Calculating jaccard similarity for k range: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ## ## Suggested k = 14 with mean jaccard similarity of: 0.984 CopyKit provides different ways to inspect the results from findSuggestedK() with plotSuggestedK(). The default geom plots a boxplot showing the mean values of each k assessed during the grid search as the red point inside each boxplot plotSuggestedK(tumor) if the argument geom is set to tile, plotSuggestedK() plots a heatmap where each row is a detected subclone, each column is a k assessed during the grid search and the color represents the jaccard similarity for a given clone. Clones not detected in a given k are presented in the color gray. plotSuggestedK(tumor, geom = &#39;tile&#39;) It is also possible to visualize the relation between subclone sizes with the jaccard similarity setting geom to scatterplot plotSuggestedK(tumor, geom = &#39;scatterplot&#39;) ## `geom_smooth()` using formula &#39;y ~ x&#39; The suggested value is stored into the metadata and can be accessed at: S4Vectors::metadata(tumor)$suggestedK ## [1] 14 6.5.2 findClusters() To run findClusters() simply use the function in the CopyKit object and provide the k value with the arguments ‘k_superclones’ and ‘k_subclones.’ NOTE: k_superclones and k_subclones can be used concurrently. Only k_subclones is a mandatory field. By default, findClusters() will use the hdbscan method for clustering tumor &lt;- findClusters(tumor, k_superclones = 30, k_subclones = 15) If findSuggestedK() was used and the argument ‘k_subclones’ is not provided, findClusters() will automatically use the value resulting from findSuggestedK() that was stored into the metadata: tumor &lt;- findClusters(tumor) ## Using suggested k_subclones = 14 ## Finding clusters, using method: hdbscan ## Found 4 subclones. ## Done. If the method used for clustering was hdbscan, it is possible that a subgroup of outliers is identified, those are added to subgroup c0 and may be removed by subsetting the copykit object. Copykit will inform if any cell was classified as c0 in an informative message after running findClusters() tumor &lt;- tumor[,colData(tumor)$subclones != &#39;c0&#39;] The results from the clustering can be visualized with different plotting functions. For example plotUmap() can be used with the argument ‘label’: plotUmap(tumor, label = &#39;subclones&#39;) ## Plotting Umap. ## Coloring by: subclones. 6.6 runPhylo() CopyKit can store phylogenetic trees inside the scCNA object. To run a phylogenetic tree simply use the function runPhylo(). The resulting tree is stored within the scCNA object in the phylo slot: tumor &lt;- runPhylo(tumor, metric = &#39;manhattan&#39;) ## Using ratio data... ## Calculating distance matrix ## Creating neighbor-joining tree. ## Access slot with copykit::phylo(scCNA). ## Done. 6.7 plotPhylo() Resulting phylogenetic trees from runPhylo() can be plotted with the function plotPhylo() plotPhylo(tumor) plotPhylo() can use any element of the metadata to color the leaves of the tree plotPhylo(tumor, label = &#39;subclones&#39;) 6.8 calcInteger() Segment mean ratios can be scaled to integer values, this process of ploidy scaling is accomplished within CopyKit with calcInteger(). CopyKit supports different methods of calculating integer copy number profiles. To calculate computational ploidies CopyKit adopts the scquantum package. To use scquantum just set the argument method to scquantum. tumor &lt;- calcInteger(tumor, method = &#39;scquantum&#39;) By setting the argument method to fixed, a fixed value of ploidy (generally determined using Flow Cytometry) will scale all cells. tumor &lt;- calcInteger(tumor, ploidy_value = 4.3) ## Scaling ratio values by ploidy value 4.3 Alternatively, if different ploidies are needed for different cells, a vector containing the ploidies can be passed on to calcInteger() as long as it contains the same length and sample order as colData() The integer segment mean ratios are stored in the slot integer that can be accessed with the function assay() If a value of ploidy exists, plotRatio() will use it to plot the integer copy number values as a secondary axis. plotRatio(tumor, &quot;PMTC6LiverC117AL4L5S1_S885_L003_R1_001&quot;) 6.9 plotHeatmap() A heatmap can be used to visualize the copy number profiles of the dataset annotated with the subclonal information: plotHeatmap(tumor, label = &#39;subclones&#39;) ## Plotting Heatmap. Integer copy number heatmaps can be plotted with plotHeatmap() and the argument assay = 'integer', importantly the integer matrix must be in the 'integer' slot. plotHeatmap(tumor, assay = &#39;integer&#39;) ## Plotting Heatmap. Importantly, new information can be added to the metadata and used in conjunction with the plotting functions. The dataset in this example has some spatial information obtained from the macrodissection of the tissue. It is encoded in the sample name by the letter S followed by a number. We can extract that information and add it as an extra column to the metadata: colData(tumor)$spatial_info &lt;- stringr::str_extract(colData(tumor)$sample, &quot;L[0-9]&quot;) Once the information has been added, we can use it to color the heatmap points by their spatial information: plotUmap(tumor, label = &#39;spatial_info&#39;) ## Plotting Umap. ## Coloring by: spatial_info. It is also possible to annotate the heatmap with that information: The ‘label’ argument for plotHeatmap() can add as many annotations as specified by the user as long as they are elements in colData() of the CopyKit object. plotHeatmap(tumor, label = c(&quot;spatial_info&quot;, &quot;subclones&quot;)) ## Plotting Heatmap. If calcInteger() was performed, it is possible to visualize how much the copy number calls deviate from the expected integer states by using plotHeatmap() with the argument rounding_error set to TRUE plotHeatmap(tumor, label = &#39;subclones&#39;, assay = &#39;integer&#39;, rounding_error = TRUE) ## Plotting Heatmap. 6.10 plotFreq() Computing the frequencies of genomic gain or losses across the genome can be useful to visualize the differences between groups. This can be done with plotFreq(). For every region of the genome, plotFreq() will calculate the frequency of gain or losses according to a determined threshold across all samples. The thresholds are controlled with the arguments low_threshold (values below this value will be counted as genomic losses) and high_threshold (values above this value will be counted as genomic gains). Ideally those values will be set accordingly to the ploidy of the sample. the sample used in the example throughout this documentation has a ploidy of approximately 4.3, therefore a gain or loss of one copy number for this sample should have a difference in the segment ratio value of 1/4.3 (~0.23). Therefore we will set the accordingly to a difference of plus or minus 0.2 (leaving some room for error), compared to a segment ratio of 1. The argument assay can be provided to pass on the integer assay instead of the segment_ratios assay. Two geoms are available area or line plotFreq(tumor, low_threshold = 0.8, high_threshold = 1.2) Group information can be set to any categorical element of the metadata and is provided with the argument label. If no information is provided on label a frequency plot of the entire sample will be plotted. plotFreq(tumor, low_threshold = 0.8, high_threshold = 1.2, label = &#39;spatial_info&#39;) 6.11 calcConsensus() Consensus sequences can help visualize the different segments across the groups of cells. A consensus sequence can be calculated in CopyKit with the function calcConsensus() tumor &lt;- calcConsensus(tumor) plotHeatmap() can also plot consensus heatmap of the CopyKit object: plotHeatmap(tumor, consensus = TRUE, label = &#39;subclones&#39;) ## Plotting Heatmap. By default calcConsensus() uses the subclones information to calculate a consensus for each subclone. Importantly, any element of the colData() can be used to calculate the consensus. tumor &lt;- calcConsensus(tumor, consensus_by = &quot;spatial_info&quot;) plotHeatmap(tumor, consensus = TRUE, label = &#39;spatial_info&#39;) ## Plotting Heatmap. Note: Consensus matrices can be calculated from the integer assay. Importantly, the integer matrix must be in the assay(scCNA, 'integer') slot. Check calcInteger() for more info. tumor &lt;- calcConsensus(tumor, consensus_by = &#39;subclones&#39;, assay = &#39;integer&#39;) 6.12 plotConsensusLine() To make it easier to compare the differences among subclones, plotConsensusLine() opens an app where the consensus sequences are plotted as lines and a checkbox can be used to add overlays of the sequences. Making it easier to determine the differences between regions. plotConsensusLine(tumor) 6.13 findVariableGenes() Finding variable genes can provide important information as to which genes contribute the most to the subclonal structure of the sample. This can be done with findVariableGenes(). findVariableGenes() requires a list of genes to be provided with the argument genes. To facilitate CopyKit provides a list of 100 putative oncogenes and tumor supressor genes from Davoli et al. in a vector called tumor_genes which is loaded with CopyKit. The argument top_n controls the number of genes to be returned tumor &lt;- findVariableGenes(tumor, genes = tumor_genes, top_n = 30) ## Warning in findVariableGenes(tumor, genes = tumor_genes, top_n = 30): Genes: H3F3A, ## MYCL1 ,could not be found. Maybe you need to use a different gene alias? ## Warning in findVariableGenes(tumor, genes = tumor_genes, top_n = 30): Genes: BCL6, HRAS, ## SMAD2 are in blacklisted regions of the Varbin pipeline and can&#39;t be plotted. The resulting list of variable genes is stored within the metadata of the CopyKit object. metadata(tumor)$hvg ## [1] &quot;SPOP&quot; &quot;COL1A1&quot; &quot;ARID2&quot; &quot;KIT&quot; &quot;KRAS&quot; &quot;CDK4&quot; &quot;CDH1&quot; &quot;IL7R&quot; &quot;PDGFRA&quot; ## [10] &quot;BRCA2&quot; &quot;RB1&quot; &quot;WT1&quot; &quot;RUNX1&quot; &quot;ERG&quot; &quot;MED12&quot; &quot;MDM2&quot; &quot;ATRX&quot; &quot;MDM4&quot; ## [19] &quot;CDKN1A&quot; &quot;FGFR1&quot; &quot;DAXX&quot; &quot;NRAS&quot; &quot;U2AF1&quot; &quot;BRCA1&quot; &quot;ERBB2&quot; &quot;NOTCH2&quot; &quot;MYB&quot; ## [28] &quot;APC&quot; &quot;PIK3CA&quot; &quot;AR&quot; ## attr(,&quot;pca_pc1_loading&quot;) ## CDK4 CDKN1A CDKN1B CDKN2A CHEK1 COL1A1 ## -0.0146710466 0.0084660752 0.0043957841 0.0026456534 -0.0053863527 -0.4384591274 ## CTNNB1 DAXX DNMT3A EGFR ARID2 EIF4A2 ## -0.0029141386 0.0078996898 0.0013694282 0.0030274619 -0.0235771528 0.0028023882 ## ERBB2 AKT1 ERG AKT2 ETV1 ETV6 ## -0.0074511420 0.0003801861 -0.0101644600 0.0022627742 -0.0021560482 0.0048660609 ## FGFR1 FGFR3 FGFR2 FLT3 SF3B1 ALK ## -0.0081407244 -0.0038136195 -0.0001337979 0.0038390034 0.0020168912 -0.0009974426 ## GATA2 GATA3 SETD2 MSH6 APC IDH1 ## -0.0011920018 -0.0035316184 -0.0003032341 0.0002113814 -0.0060846679 0.0007084374 ## IDH2 FAS IL7R AR JAK1 JAK2 ## 0.0017993149 0.0035946974 0.0129418231 0.0055880251 0.0010669074 0.0047430418 ## JUN KIT KRAS SMAD4 MDM2 MDM4 ## 0.0004731041 -0.0172508537 -0.0172106303 -0.0012651471 -0.0091080232 -0.0086123883 ## MAP3K1 MEN1 MET MLH1 KMT2A MSH2 ## -0.0047596728 -0.0042184330 0.0009217338 -0.0001570824 -0.0037168347 0.0002113814 ## MYB MYC MYCN MYD88 ATM NF1 ## -0.0066053909 0.0031013296 -0.0003195861 -0.0008913659 -0.0046481874 -0.0032873824 ## NF2 NOTCH1 NOTCH2 NRAS PDGFRA PIK3CA ## -0.0030206444 0.0013750952 -0.0069624215 -0.0078532084 -0.0120269384 0.0058221809 ## ATR ATRX TET2 BCOR PPP2R1A FBXW7 ## 0.0027890046 0.0089562314 0.0011002944 0.0040349846 0.0006695846 -0.0028489702 ## PTEN ARID1B KMT2C RB1 CCND1 MAP2K4 ## 0.0036215605 0.0010770593 0.0014878799 0.0115272745 -0.0036230716 0.0006150178 ## SMARCA4 SMARCB1 SOX2 BRCA1 BRAF BRCA2 ## 0.0047877089 -0.0013007426 0.0055466873 -0.0074511420 0.0017498759 0.0118541800 ## STK11 TP53 TSC1 TSC2 U2AF1 VHL ## 0.0011929999 0.0024032218 0.0012141721 -0.0015389427 -0.0077895360 0.0041595643 ## WT1 KMT2D ARID1A AXIN1 BAP1 SPOP ## 0.0105175617 0.0001220848 0.0026352946 -0.0015389427 -0.0009143539 -0.8965817276 ## CASP8 RUNX1 CCNE1 MED12 CDH1 ## 0.0024764568 -0.0101846929 -0.0025175166 0.0092907801 0.0136316509 ## attr(,&quot;pca_df&quot;) ## gene p1 ## SPOP SPOP -0.8965817276 ## COL1A1 COL1A1 -0.4384591274 ## ARID2 ARID2 -0.0235771528 ## KIT KIT -0.0172508537 ## KRAS KRAS -0.0172106303 ## CDK4 CDK4 -0.0146710466 ## CDH1 CDH1 0.0136316509 ## IL7R IL7R 0.0129418231 ## PDGFRA PDGFRA -0.0120269384 ## BRCA2 BRCA2 0.0118541800 ## RB1 RB1 0.0115272745 ## WT1 WT1 0.0105175617 ## RUNX1 RUNX1 -0.0101846929 ## ERG ERG -0.0101644600 ## MED12 MED12 0.0092907801 ## MDM2 MDM2 -0.0091080232 ## ATRX ATRX 0.0089562314 ## MDM4 MDM4 -0.0086123883 ## CDKN1A CDKN1A 0.0084660752 ## FGFR1 FGFR1 -0.0081407244 ## DAXX DAXX 0.0078996898 ## NRAS NRAS -0.0078532084 ## U2AF1 U2AF1 -0.0077895360 ## BRCA1 BRCA1 -0.0074511420 ## ERBB2 ERBB2 -0.0074511420 ## NOTCH2 NOTCH2 -0.0069624215 ## MYB MYB -0.0066053909 ## APC APC -0.0060846679 ## PIK3CA PIK3CA 0.0058221809 ## AR AR 0.0055880251 ## SOX2 SOX2 0.0055466873 ## CHEK1 CHEK1 -0.0053863527 ## ETV6 ETV6 0.0048660609 ## SMARCA4 SMARCA4 0.0047877089 ## MAP3K1 MAP3K1 -0.0047596728 ## JAK2 JAK2 0.0047430418 ## ATM ATM -0.0046481874 ## CDKN1B CDKN1B 0.0043957841 ## MEN1 MEN1 -0.0042184330 ## VHL VHL 0.0041595643 ## BCOR BCOR 0.0040349846 ## FLT3 FLT3 0.0038390034 ## FGFR3 FGFR3 -0.0038136195 ## KMT2A KMT2A -0.0037168347 ## CCND1 CCND1 -0.0036230716 ## PTEN PTEN 0.0036215605 ## FAS FAS 0.0035946974 ## GATA3 GATA3 -0.0035316184 ## NF1 NF1 -0.0032873824 ## MYC MYC 0.0031013296 ## EGFR EGFR 0.0030274619 ## NF2 NF2 -0.0030206444 ## CTNNB1 CTNNB1 -0.0029141386 ## FBXW7 FBXW7 -0.0028489702 ## EIF4A2 EIF4A2 0.0028023882 ## ATR ATR 0.0027890046 ## CDKN2A CDKN2A 0.0026456534 ## ARID1A ARID1A 0.0026352946 ## CCNE1 CCNE1 -0.0025175166 ## CASP8 CASP8 0.0024764568 ## TP53 TP53 0.0024032218 ## AKT2 AKT2 0.0022627742 ## ETV1 ETV1 -0.0021560482 ## SF3B1 SF3B1 0.0020168912 ## IDH2 IDH2 0.0017993149 ## BRAF BRAF 0.0017498759 ## TSC2 TSC2 -0.0015389427 ## AXIN1 AXIN1 -0.0015389427 ## KMT2C KMT2C 0.0014878799 ## NOTCH1 NOTCH1 0.0013750952 ## DNMT3A DNMT3A 0.0013694282 ## SMARCB1 SMARCB1 -0.0013007426 ## SMAD4 SMAD4 -0.0012651471 ## TSC1 TSC1 0.0012141721 ## STK11 STK11 0.0011929999 ## GATA2 GATA2 -0.0011920018 ## TET2 TET2 0.0011002944 ## ARID1B ARID1B 0.0010770593 ## JAK1 JAK1 0.0010669074 ## ALK ALK -0.0009974426 ## MET MET 0.0009217338 ## BAP1 BAP1 -0.0009143539 ## MYD88 MYD88 -0.0008913659 ## IDH1 IDH1 0.0007084374 ## PPP2R1A PPP2R1A 0.0006695846 ## MAP2K4 MAP2K4 0.0006150178 ## JUN JUN 0.0004731041 ## AKT1 AKT1 0.0003801861 ## MYCN MYCN -0.0003195861 ## SETD2 SETD2 -0.0003032341 ## MSH2 MSH2 0.0002113814 ## MSH6 MSH6 0.0002113814 ## MLH1 MLH1 -0.0001570824 ## FGFR2 FGFR2 -0.0001337979 ## KMT2D KMT2D 0.0001220848 Results are on decreasing order from most variable to list variable. The results can be visualized with plotVariableGenes() and plotGeneCopy(). Importantly, findVariableGenes() cannot be used as a comparison of groups but as a way of finding the most variable genes across the entire sample. Another thing to be aware is that genes that are overexpressed and present diversity of copy number states tend to be oncogenes, therefore using only findVariableGenes() as a discovery tool can under emphasize events in important tumor supressor genes across a sample. 6.14 plotVariableGenes() plotVariableGenes() is a visualization for the results from findVariableGenes(). plotVariableGenes(tumor) 6.15 plotGeneCopy() It might be of interest to check for the copy number states across all the samples for different genes. That can be done with plotGeneCopy() in two different geoms: “swarm” (default) or “violin.” As with other plot functions, points can be colored with the argument ‘label.’ plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), label = &#39;spatial_info&#39;) ## Coloring by: spatial_info plotGeneCopy() can be specially useful to visualize the result from findVariableGenes() plotGeneCopy(tumor, genes = metadata(tumor)$hvg, label = &#39;spatial_info&#39;) ## Coloring by: spatial_info A barplot geom is also provided to visualize the integer data as a frequency barplot for each gene: plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), geom = &#39;barplot&#39;, assay = &#39;integer&#39;) "],["session-info.html", "7 Session Info", " 7 Session Info sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.8.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 ## [4] LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C ## [10] LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] copykit_0.0.0.9025 SingleCellExperiment_1.14.1 SummarizedExperiment_1.22.0 ## [4] Biobase_2.52.0 GenomicRanges_1.44.0 GenomeInfoDb_1.28.2 ## [7] IRanges_2.26.0 S4Vectors_0.30.0 BiocGenerics_0.38.0 ## [10] MatrixGenerics_1.4.3 matrixStats_0.60.1 BiocParallel_1.26.2 ## [13] bookdown_0.23 devtools_2.4.2 usethis_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] utf8_1.2.2 reticulate_1.20 tidyselect_1.1.1 ## [4] grid_4.1.0 munsell_0.5.0 aCGH_1.70.0 ## [7] ScaledMatrix_1.0.0 codetools_0.2-18 statmod_1.4.36 ## [10] scran_1.20.1 miniUI_0.1.1.1 withr_2.4.2 ## [13] colorspace_2.0-2 highr_0.9 knitr_1.33 ## [16] rstudioapi_0.13 robustbase_0.93-8 Rsubread_2.6.4 ## [19] labeling_0.4.2 GenomeInfoDbData_1.2.6 farver_2.1.0 ## [22] rprojroot_2.0.2 vctrs_0.3.8 treeio_1.16.2 ## [25] generics_0.1.0 xfun_0.23 fastcluster_1.2.3 ## [28] diptest_0.76-0 R6_2.5.1 doParallel_1.0.16 ## [31] ggbeeswarm_0.6.0 clue_0.3-59 rsvd_1.0.5 ## [34] locfit_1.5-9.4 pals_1.7 flexmix_2.3-17 ## [37] bitops_1.0-7 cachem_1.0.6 DelayedArray_0.18.0 ## [40] assertthat_0.2.1 promises_1.2.0.1 scales_1.1.1 ## [43] nnet_7.3-16 beeswarm_0.4.0 gtable_0.3.0 ## [46] beachmat_2.8.1 Cairo_1.5-12.2 processx_3.5.2 ## [49] rlang_0.4.11 GlobalOptions_0.1.2 splines_4.1.0 ## [52] lazyeval_0.2.2 dichromat_2.0-0 yaml_2.2.1 ## [55] httpuv_1.6.2 tools_4.1.0 ggplot2_3.3.5 ## [58] ellipsis_0.3.2 jquerylib_0.1.4 RColorBrewer_1.1-2 ## [61] DNAcopy_1.66.0 sessioninfo_1.1.1 Rcpp_1.0.7 ## [64] sparseMatrixStats_1.4.2 zlibbioc_1.38.0 purrr_0.3.4 ## [67] RCurl_1.98-1.4 ps_1.6.0 prettyunits_1.1.1 ## [70] dbscan_1.1-8 viridis_0.6.1 GetoptLong_1.0.5 ## [73] cowplot_1.1.1 cluster_2.1.2 fs_1.5.0 ## [76] magrittr_2.0.1 RSpectra_0.16-0 magick_2.7.3 ## [79] data.table_1.14.0 circlize_0.4.13 amap_0.8-18 ## [82] ggnewscale_0.4.5 pkgload_1.2.1 patchwork_1.1.1 ## [85] mime_0.11 evaluate_0.14 xtable_1.8-4 ## [88] mclust_5.4.7 gridExtra_2.3 shape_1.4.6 ## [91] testthat_3.0.4 compiler_4.1.0 tibble_3.1.4 ## [94] maps_3.3.0 crayon_1.4.1 htmltools_0.5.2 ## [97] mgcv_1.8-36 segmented_1.3-4 ggfun_0.0.3 ## [100] later_1.3.0 tidyr_1.1.3 aplot_0.0.6 ## [103] lubridate_1.7.10 DBI_1.1.1 ComplexHeatmap_2.8.0 ## [106] MASS_7.3-54 fpc_2.2-9 boot_1.3-28 ## [109] leidenbase_0.1.3 Matrix_1.3-4 cli_3.0.1 ## [112] metapod_1.0.0 igraph_1.2.6 forcats_0.5.1 ## [115] pkgconfig_2.0.3 scuttle_1.2.1 foreach_1.5.1 ## [118] ggtree_3.0.4 vipor_0.4.5 bslib_0.2.5.1 ## [121] dqrng_0.3.0 multtest_2.48.0 XVector_0.32.0 ## [124] snakecase_0.11.0 yulab.utils_0.0.2 stringr_1.4.0 ## [127] callr_3.7.0 digest_0.6.27 janitor_2.1.0 ## [130] Biostrings_2.60.2 rmarkdown_2.10 leiden_0.3.9 ## [133] tidytree_0.3.4 uwot_0.1.10 edgeR_3.34.0 ## [136] DelayedMatrixStats_1.14.3 curl_4.3.2 kernlab_0.9-29 ## [139] shiny_1.6.0 Rsamtools_2.8.0 gtools_3.9.2 ## [142] modeltools_0.2-23 rjson_0.2.20 lifecycle_1.0.0 ## [145] nlme_3.1-152 jsonlite_1.7.2 BiocNeighbors_1.10.0 ## [148] mapproj_1.2.7 viridisLite_0.4.0 desc_1.3.0 ## [151] limma_3.48.3 fansi_0.5.0 pillar_1.6.2 ## [154] lattice_0.20-44 DEoptimR_1.0-9 fastmap_1.1.0 ## [157] pkgbuild_1.2.0 survival_3.2-11 glue_1.4.2 ## [160] remotes_2.4.0 FNN_1.1.3 png_0.1-7 ## [163] prabclus_2.3-2 iterators_1.0.13 bluster_1.2.1 ## [166] mixtools_1.2.0 class_7.3-19 stringi_1.7.4 ## [169] sass_0.4.0 BiocSingular_1.8.1 memoise_2.0.0 ## [172] dplyr_1.0.7 irlba_2.3.3 ape_5.5 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
