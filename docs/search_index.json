[
["index.html", "CopyKit User Guide 1 Introduction", " CopyKit User Guide Darlan Conterno Minussi Last revised: 2021-06-14 1 Introduction This is the user guide for the CopyKit package. CopyKit is a toolkit for single-cell analysis of copy number datasets. Copykit expands from the existing robust scaffold for single-cell analysis provided by the Bioconductor packages SingleCellExperiment and SummarizedExperiment and, provides the tools to perform binning of sequencing reads, segmentation as well as quality control and downstream analysis of scDNA-Seq datasets. CopyKit uses the Variable Binning (Baslan et al. 2012; Gao et al. 2016) pipeline to process datasets. All the information from a scDNA-Seq dataset is stored within the scCNA object for downstream analysis. CopyKit functions can be split into 4 modules: 1) Pre-processing, 2) Quality Control, 3) Analysis and, 4) Visualization module. The next chapters of this user guide will cover each module in detail. "],
["parallelization.html", "2 Parallelization", " 2 Parallelization For all parallel calculations, CopyKit adopts the BiocParallel framework. Make sure to read the BiocParallel vignette to choose the best parameters for your machine. An example workflow can be done as follows: We use BiocParallel::register() function to register the number of workers desired. library(BiocParallel) register(MulticoreParam(workers = 40, progressbar = T), default = T) BiocParallel registered 40 processes for parallelization of copykit functions. The default parameter can be confirmed with: BiocParallel::bpparam() ## class: MulticoreParam ## bpisup: FALSE; bpnworkers: 40; bptasks: 0; bpjobname: BPJOB ## bplog: FALSE; bpthreshold: INFO; bpstopOnError: TRUE ## bpRNGseed: ; bptimeout: 2592000; bpprogressbar: FALSE ## bpexportglobals: TRUE ## bplogdir: NA ## bpresultdir: NA ## cluster type: FORK The argument progressbar allows for a helpful progression bar while the process is being run. After this setup CopyKit parallelized functions will automatically recognize these parameters and run in parallel. It is highly recommended to run CopyKit using parallelization since some functions can take a long time to run otherwise. "],
["pre-processing.html", "3 Pre-processing 3.1 runVarbin()", " 3 Pre-processing CopyKit pre-processing module consists of 1 function that performs 3 main processes: Counts reads from the from the .bam files Applies a variance stabilization transformation to the dataset Segments the data into piece-wise constant function for inference of copy number states 3.1 runVarbin() First we load CopyKit with the library() function library(copykit) NOTE: CopyKit functions will automatically run in parallel if the BiocParallel framework was registered. For more information check section 2. runVarbin() accepts duplicates marked .bam files as input and performs the binning of reads into bins according to the variable binning pipeline (Baslan et al. 2012; Gao et al. 2016). To help users obtain these processed files from .fastq files a snakemake pipeline is available here that uses bowtie2 for the alignment of reads and sambamba for the removal of pcr duplicates. This pipeline can be adapted as per users’ needs and the only requirement for CopyKit is the use of .bam files as the input. runVarbin() the first argument should be the path to the .bam files location. tumor &lt;- runVarbin(&quot;~/path/to/bam/files/&quot;, remove_Y = TRUE) ## Counting reads. ## Performing GC correction. ## Done. ## Running segmentation algorithm: CBS for genome hg38 ## Done. runVarbin() by default uses a varbin pipeline scaffold for the genome hg38 with a resolution of bins with an average size of 200kb. Both options can be changed with the arguments genome or resolution. For samples that are XX, runVarbin() can be set to ignore any read that may have aligned to chrY with the argument remove_Y = TRUE. A consequence of the count nature of copy-number sequencing data is a negative binomial distribution with overdispersion at higher counts. To account for that CopyKit offers a variance stabilization transformation procedure with the function runVst(). By default, CopyKit will apply the freeman-tukey transformation to the bin count dataset. The resulting object is the CopyKit object of class scCNA that can be inspected. tumor ## class: scCNA ## dim: 10327 782 ## metadata(2): genome vst ## assays(4): segment_ratios ratios bin_counts ft ## rownames(10327): 1 2 ... 10326 10327 ## rowData names(4): abspos bin_length mappable_positions gc_content ## colnames(782): TN28_2_S1_C10_S1930_L006_R1_001 TN28_2_S1_C10_S19300_L006_R1_001 ... ## TN28_3_S1_C114_S2418_L007_R1_001 TN28_3_S1_C114_S24180_L007_R1_001 ## colData names(9): sample reads_assigned_bins ... reads_total percentage_duplicates ## reducedDimNames(0): ## spikeNames(0): ## altExpNames(0): ## rowRanges has: 10327 ranges ## Phylo: Phylogenetic tree with 0 tips and nodes ## consensus dim: 0 0 CopyKit objects expand on the SingleCellExperiment class where each column represents a single-cell and each row represents a bin. The information of the bincounts resulting from runVarbin() are stored withing the bin_counts slot that can be acessed with the bin_counts() accessor. (Here displaying the first five columns). head(bin_counts(tumor)[,1:5]) ## TN28.2.S1.C10.S1930.L006.R1.001.bam TN28.2.S1.C10.S19300.L006.R1.001.bam TN28.2.S1.C100.S2020.L006.R1.001.bam ## 1 62.38872 54.09573 61.57994 ## 2 53.65437 44.13231 91.03379 ## 3 59.41748 68.71880 71.76582 ## 4 28.59606 38.60081 71.23185 ## 5 47.09882 47.24148 51.71587 ## 6 73.32089 63.24496 68.05133 ## TN28.2.S1.C100.S20200.L006.R1.001.bam TN28.2.S1.C101.S2021.L006.R1.001.bam ## 1 60.82263 55.75554 ## 2 56.60577 34.57650 ## 3 81.03261 66.17844 ## 4 67.86454 58.88123 ## 5 54.59423 55.61802 ## 6 33.01010 47.68769 Classically copy number data has been transformed with a logarithm transformation, the log transformation can be set within CopyKit with the argument runVst(copykit_object, transformation = 'log). Warning The segmentation step (see next section) can be very slow when transformation = ‘log’ is selected. Even though the process is fast for most cells it can hang in a few cells with large breakpoint numbers and take ~ 1hr to complete. The resulting transformation is stored within the CopyKit object in the ft slot if freeman-tukey was performed and can be accessed with the assay() function: head(assay(tumor, &#39;ft&#39;)[,1:5]) ## TN28.2.S1.C10.S1930.L006.R1.001.bam TN28.2.S1.C10.S19300.L006.R1.001.bam TN28.2.S1.C100.S2020.L006.R1.001.bam ## 1 15.86036 14.77763 15.75804 ## 2 14.71777 13.36127 19.13459 ## 3 15.48114 16.63946 17.00176 ## 4 10.78775 12.50587 16.93883 ## 5 13.79819 13.81885 14.45194 ## 6 17.18372 15.96797 16.55904 ## TN28.2.S1.C100.S20200.L006.R1.001.bam TN28.2.S1.C101.S2021.L006.R1.001.bam ## 1 15.66162 15.00059 ## 2 15.11353 11.84478 ## 3 18.05900 16.33126 ## 4 16.53646 15.41171 ## 5 14.84494 14.98224 ## 6 11.57726 13.88328 Lastly segmentation fits piece-wise constant functions to every profile generating segment means that can be used to infer copy-number states across every cell. By default, CopyKit uses Circular Binary Segmentation (CBS) from the DNAcopy package to perform segmentation. The resulting information from runSegmentation() is stored within the CopyKit object into two different assays: ratios and segment_ratios, which can be accessed with the helper function ratios() and segment_ratios() head(ratios(tumor)[,1:5]) ## TN28_2_S1_C10_S1930_L006_R1_001 TN28_2_S1_C10_S19300_L006_R1_001 TN28_2_S1_C100_S2020_L006_R1_001 ## 1 0.7378685 0.7024296 0.9143198 ## 2 0.6345678 0.5730553 1.3516414 ## 3 0.7027278 0.8923094 1.0655565 ## 4 0.3382042 0.5012291 1.0576283 ## 5 0.5570355 0.6134276 0.7678611 ## 6 0.8671627 0.8212318 1.0104050 ## TN28_2_S1_C100_S20200_L006_R1_001 TN28_2_S1_C101_S2021_L006_R1_001 ## 1 0.9922831 0.7337057 ## 2 0.9234876 0.4550036 ## 3 1.3219961 0.8708640 ## 4 1.1071673 0.7748376 ## 5 0.8906706 0.7318959 ## 6 0.5385390 0.6275381 head(segment_ratios(tumor)[,1:5]) ## TN28_2_S1_C10_S1930_L006_R1_001 TN28_2_S1_C10_S19300_L006_R1_001 TN28_2_S1_C100_S2020_L006_R1_001 ## 1 0.6461778 0.6079205 1.008218 ## 2 0.6461778 0.6079205 1.008218 ## 3 0.6461778 0.6079205 1.008218 ## 4 0.6461778 0.6079205 1.008218 ## 5 0.6461778 0.6079205 1.008218 ## 6 0.6461778 0.6079205 1.008218 ## TN28_2_S1_C100_S20200_L006_R1_001 TN28_2_S1_C101_S2021_L006_R1_001 ## 1 1.000416 0.6550142 ## 2 1.000416 0.6550142 ## 3 1.000416 0.6550142 ## 4 1.000416 0.6550142 ## 5 1.000416 0.6550142 ## 6 1.000416 0.6550142 From now on, the derived segment ratios will be the main type of data where the copy number analysis will be performed. "],
["qc-module.html", "4 QC module 4.1 runMetrics() 4.2 filterCells() 4.3 findNormalCells()", " 4 QC module CopyKit QC Module consists of 3 main functions: 1) runMetrics(), 2) filterCells() and 3) findNormalCells(). 4.1 runMetrics() runMetrics() is used to add basic quality control information to the metadata of the CopyKit object. It will return information on the overdispersion on the datasets and the number of breakpoints for each single-cell. tumor &lt;- runMetrics(tumor) ## Calculating RMSE ## Counting breakpoints. ## Done. The resulting information can be seen at the metadata with: colData(tumor) ## DataFrame with 782 rows and 11 columns ## sample reads_assigned_bins reads_unmapped reads_duplicates ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## TN28_2_S1_C10_S1930_L006_R1_001 TN28_2_S1_C10_S1930_L006_R1_001 840325 31177 125862 ## TN28_2_S1_C10_S19300_L006_R1_001 TN28_2_S1_C10_S19300_L006_R1_001 772672 25524 103608 ## TN28_2_S1_C100_S2020_L006_R1_001 TN28_2_S1_C100_S2020_L006_R1_001 693135 23270 83325 ## TN28_2_S1_C100_S20200_L006_R1_001 TN28_2_S1_C100_S20200_L006_R1_001 633810 19125 66229 ## TN28_2_S1_C101_S2021_L006_R1_001 TN28_2_S1_C101_S2021_L006_R1_001 742324 27998 100567 ## ... ... ... ... ... ## TN28_3_S1_C111_S24150_L007_R1_001 TN28_3_S1_C111_S24150_L007_R1_001 727963 21808 84577 ## TN28_3_S1_C112_S2416_L007_R1_001 TN28_3_S1_C112_S2416_L007_R1_001 844766 30264 150762 ## TN28_3_S1_C112_S24160_L007_R1_001 TN28_3_S1_C112_S24160_L007_R1_001 744053 23087 97090 ## TN28_3_S1_C114_S2418_L007_R1_001 TN28_3_S1_C114_S2418_L007_R1_001 688956 22883 94968 ## TN28_3_S1_C114_S24180_L007_R1_001 TN28_3_S1_C114_S24180_L007_R1_001 611706 17910 61896 ## reads_multimapped reads_unassigned reads_ambiguous reads_total percentage_duplicates ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## TN28_2_S1_C10_S1930_L006_R1_001 0 251124 171 1248659 0.1 ## TN28_2_S1_C10_S19300_L006_R1_001 0 229148 159 1131111 0.09 ## TN28_2_S1_C100_S2020_L006_R1_001 0 218355 141 1018226 0.08 ## TN28_2_S1_C100_S20200_L006_R1_001 0 198661 156 917981 0.07 ## TN28_2_S1_C101_S2021_L006_R1_001 0 217576 155 1088620 0.09 ## ... ... ... ... ... ... ## TN28_3_S1_C111_S24150_L007_R1_001 0 208928 162 1043438 0.08 ## TN28_3_S1_C112_S2416_L007_R1_001 0 249482 196 1275470 0.12 ## TN28_3_S1_C112_S24160_L007_R1_001 0 217770 158 1082158 0.09 ## TN28_3_S1_C114_S2418_L007_R1_001 0 201483 137 1008427 0.09 ## TN28_3_S1_C114_S24180_L007_R1_001 0 177354 118 868984 0.07 ## rmse breakpoint_count ## &lt;numeric&gt; &lt;numeric&gt; ## TN28_2_S1_C10_S1930_L006_R1_001 0.162557530250304 34 ## TN28_2_S1_C10_S19300_L006_R1_001 0.167298889259749 36 ## TN28_2_S1_C100_S2020_L006_R1_001 0.132508665229758 0 ## TN28_2_S1_C100_S20200_L006_R1_001 0.137765520470889 2 ## TN28_2_S1_C101_S2021_L006_R1_001 0.13896682656001 37 ## ... ... ... ## TN28_3_S1_C111_S24150_L007_R1_001 0.137535442036682 44 ## TN28_3_S1_C112_S2416_L007_R1_001 0.133106294791448 60 ## TN28_3_S1_C112_S24160_L007_R1_001 0.139080900295883 55 ## TN28_3_S1_C114_S2418_L007_R1_001 0.162255320465384 67 ## TN28_3_S1_C114_S24180_L007_R1_001 0.169867880038563 62 4.2 filterCells() filterCells() removes low-quality cells according to a defined resolution threshold. Cells with correlation smaller than the mean of its k-nearest neighbors are defined as noisy samples and this information, as well as the correlation value, is added to the scCNA object metadata. tumor &lt;- filterCells(tumor) ## Calculating correlation matrix. ## Adding information to metadata. Access with SummarizedExperiment::colData(scCNA). ## Done. The default resolution threshold is 0.9 and it can be adjusted accordingly to user needs with the argument ‘resolution’. filterCells() adds a column to the metadata called ‘filtered’ marking cells that should be removed or kept. After filtering the function plotHeatmap() from the visualization module can be used to visualize the results from filterCells() with the argument label set to ‘filtered’. To make visualization easier, rows can also be split according to elements of the metadata with the argument row_split. plotHeatmap(tumor, label = &#39;filtered&#39;, row_split = &#39;filtered&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. If satisfied with the filtering results, the CopyKit object can be subset as any other R object. tumor &lt;- tumor[,colData(tumor)$filtered == &#39;kept&#39;] 4.3 findNormalCells() It is common for datasets to contain normal cells with flat profiles mixed in with the aneuploidy cells from a tumor that is being profiled. findNormalCells() performs a sample-wise calculation of the segment ratios coefficient of variation. By default findNormalCells() tries to automatically identify the resolution threshold by fitting a normal mixture model to the distribution of coefficient of variation from all samples. To increase the sensitivity of the model, findNormalCells also simulate the expected coefficient of variation. Lastly, findNormalCells() add the resulting information to the metadata of the CopyKit object in a column named ‘is_normal’. tumor &lt;- findNormalCells(tumor) ## number of iterations= 5 ## Copykit detected 6 that are possibly normal cells using a resolution of: 0.051 ## Done. Information was added to metadata column &#39;is_normal&#39;. plotHeatmap() can again be used to visualize the results from findNormalCells() plotHeatmap(tumor, label = &#39;is_normal&#39;) ## Ordering by consensus requires cluster information. ## Switching to hclust ## No distance matrix detected in the scCNA object. ## Calculating distance matrix with metric: euclidean ## Using 48 cores. ## Access distance matrix with copykit::distMat() ## Done. The object can be subsetted in the same way as with filterCells() tumor &lt;- tumor[,colData(tumor)$is_normal == FALSE] Your dataset should be ready to proceed with the analysis. "],
["analysis-and-visualization-module.html", "5 Analysis and Visualization module 5.1 plotRatio() 5.2 runUmap() 5.3 plotUmap() 5.4 Clustering 5.5 plotHeatmap() 5.6 calcConsensus() 5.7 plotConsensusLine() 5.8 calcInteger() 5.9 plotGeneCopy()", " 5 Analysis and Visualization module The analysis and visualization module from CopyKit work in synergy to help you analyze and assess the results from your day. The analysis module provides the following functions: runUmap(), calcInteger(), findSuggestedK(), findClusters(), calcConsensus() and runPhylo(). The visualization module functions are: plotMetrics(), plotRatio(), plotUmap(), plotHeatmap(), plotConsensusLine() and plotGeneCopy(). 5.1 plotRatio() It is often important to visualize that the segmentation behaved as expected and closely follows the ratios. Not missing important events. Ratio plots are a great tool for this. You can plot ratio plots with the plotRatio() function. plotRatio() has two different modes. When the input is the CopyKit object an interactive app will run and you can select which cell will be visualized. plotRatio(tumor) If plotRatio() is given a sample name only the plot for that cell will be shown. plotRatio(tumor, &quot;TN28_2_S1_C10_S1930_L006_R1_001&quot;) 5.2 runUmap() runUmap uses generates a UMAP reduced dimensions embedding, the resulting embedding is stored within the scCNA reducedDim slot and is an important pre-processing step to the findClusters feature. tumor &lt;- runUmap(tumor) ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;umap&#39;). ## Done. Additional arguments to control umap parameters can be passed on torunUmap() with the ‘…’ argument. tumor &lt;- runUmap(tumor, n_neighbors = 30, min_dist = 0) ## Embedding data with UMAP. Using seed 17 ## Access reduced dimensions slot with: SingleCellExperiment::reducedDim(scCNA, &#39;umap&#39;). ## Done. 5.3 plotUmap() plotUmap() can be used to plot the reduced dimensional embedding. plotUmap can be colored by any element of the metadata with the argument ‘label’, this will be shown in a later section. plotUmap(tumor) ## Plotting Umap. ## No cluster information detected, use findClusters() to create it. 5.4 Clustering The findClusters() function will use the reduced dimensional embedding resulting from runUmap to perform clustering of superclones and subclones. When clustering for superclones findClusters() creates a graph representation of the dataset reduced dimension embedding using a shared nearest neighbor algorithm (SNN), from this graph the connected components are extracted and generally represent high-level structures that share large, lineage defining copy number events. CopyKit can also be used to detect subclones, i. e. groups of cells containing a unique copy number event per cluster, to do so the umap embedding is again used as the pre-processing step, this time to perform a density-based clustering with hdbscan as seen in the work from Laks et al. (???). 5.4.1 findSugestedK() Density-based clustering requires the input of the k neighbors, frequently chosen ad hoc. To help with parametrization, CopyKit provides the helper findSuggestedK function. findSuggestedK performs a clustering bootstrapping over a range of k values and returns the value that maximizes the jaccard similarity. While findSuggestedK does not guarantee that the suggested value will result in optimal clustering but provides a guide that maximizes cluster stability. tumor &lt;- findSuggestedK(tumor) ## Calculating jaccard similarity for k range: 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## ## Suggested k = 9 with mean jaccard similarity of: 0.742 The suggested value is stored into the metadata and can be accessed at: S4Vectors::metadata(tumor)$suggestedK ## [1] 9 5.4.2 findClusters() To run findClusters() simply use the function in the CopyKit object and provide the k value with the arguments ‘k_superclones’ and ‘k_subclones’. NOTE: k_superclones and k_subclones can be used concurrently. Only k_subclones is a mandatory field. tumor &lt;- findClusters(tumor, k_superclones = 30, k_subclones = 15) ## Finding clusters, using method: hdbscan ## Done. If findSuggestedK() was used and the argument ‘k_subclones’ is not provided, findClusters() will automatically use the value resulting from findSuggestedK() that was stored into the metadata: tumor &lt;- findClusters(tumor) ## Using suggested k_subclones = 9 ## Finding clusters, using method: hdbscan ## Done. The results from the clustering can be visualized with different plotting functions. For example plotUmap() can be used with the argument ‘label’: plotUmap(tumor, label = &#39;subclones&#39;) ## Coloring by: subclones ## Plotting Umap. 5.5 plotHeatmap() A heatmap can be used to visualize the copy number profiles of the dataset annotated with the subclonal information: plotHeatmap(tumor, label = &#39;subclones&#39;) Importantly, new information can be added to the metadata and used in conjunction with the plotting functions. The dataset in this example has some spatial information obtained from the macrodissection of the tissue. It is encoded in the sample name by the letter S followed by a number. We can extract that information and add it as an extra column to the metadata: colData(tumor)$spatial_info &lt;- str_extract(colData(tumor)$sample, &quot;S[0-9]{1}&quot;) Once the information has been added, we can use it to color the heatmap points by their spatial information: plotUmap(tumor, label = &#39;spatial_info&#39;) ## Coloring by: spatial_info ## Plotting Umap. It is also possible to annotate the heatmap with that information: The ‘label’ argument for plotHeatmap() can add as many annotations as specified by the user as long as they are elements in colData() of the CopyKit object. plotHeatmap(tumor, label = c(&quot;spatial_info&quot;, &quot;subclones&quot;)) 5.6 calcConsensus() Consensus sequences can help visualize the different segments across the groups of cells. A consensus sequence can be calculated in CopyKit with the function calcConsensus() tumor &lt;- calcConsensus(tumor) plotHeatmap() can also plot consensus heatmap of the CopyKit object: plotHeatmap(tumor, consensus = TRUE, label = &#39;subclones&#39;) ## Warning: The input is a data frame, convert it to the matrix. By default calcConsensus() uses the subclones information to calculate a consensus for each subclone. Importantly, any element of the colData() can be used to calculate the consensus. tumor &lt;- calcConsensus(tumor, consensus_by = &quot;spatial_info&quot;) plotHeatmap(tumor, consensus = TRUE, label = &#39;spatial_info&#39;) ## Warning: The input is a data frame, convert it to the matrix. 5.7 plotConsensusLine() To make it easier to compare the differences among subclones, plotConsensusLine() opens an app where the consensus sequences are plotted as lines and a checkbox can be used to add overlays of the sequences. Making it easier to determine the differences between regions. plotConsensusLine(tumor) 5.8 calcInteger() Segment mean ratios can be scaled to integer values, this process of ploidy scaling is accomplished within CopyKit with calcInteger(). CopyKit supports using a fixed value of ploidy that will scale all the cells (generally determined using Flow Cytometry). Alternatively, if different ploidies are needed for different cells, a vector containing the ploidies can be passed on to calcInteger() as long as it contains the same length and sample order as colData() tumor &lt;- calcInteger(tumor, ploidy_value = 3.45) ## Scaling ratio values by ploidy value 3.45 The integer segment mean ratios are stored in the slot integer that can be accessed with the function assay() If a value of ploidy exists, plotRatio() will use it to plot the integer copy number values as a secondary axis. plotRatio(tumor, &quot;TN28_2_S1_C10_S1930_L006_R1_001&quot;) 5.9 plotGeneCopy() It might be of interest to check for the copy number states across all the samples for different genes. That can be done with plotGeneCopy() in two different geoms: “swarm” (default) or “violin”. As with other plot functions, points can be colored with the argument ‘label’. plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), label = &#39;spatial_info&#39;) ## Coloring by: spatial_info It is also possible to visualize the integer data as a frequency barplot for each gene: plotGeneCopy(tumor, genes = c(&quot;CDKN2A&quot;, &quot;FGFR1&quot;, &quot;TP53&quot;, &quot;PTEN&quot;, &quot;MYC&quot;, &quot;CDKN1A&quot;, &quot;MDM2&quot;, &quot;AURKA&quot;, &quot;PIK3CA&quot;, &quot;CCND1&quot;, &quot;KRAS&quot;), geom = &#39;barplot&#39;, assay = &#39;integer&#39;) "]
]
