# Analysis and Visualization module

The analysis and visualization module from CopyKit work in synergy to help you analyze your single cell copy number results.

## plotMetrics()

The `plotMetrics()` function can plot any information store in `colData()`, which is passedto the `metric` argument. If a `label` argument is supplied, the points will be colored based on that information.
```{r}
plotMetrics(tumor, metric = c("overdispersion", 
                              "breakpoint_count",
                              "reads_total",
                              "reads_duplicates",
                              "reads_assigned_bins",
                              "percentage_duplicates"),
            label = "percentage_duplicates")
```

## plotRatio()

Visualizing the seegmeentation to eensure it follows the ratios as expected is crucial to a copy number analysis.
This helps to verify the accuracy of the segmentation an assess the quality of the data visually.

The `plotRatio()` function is a useful tool for this, offering two different modes. When the input is the CopyKit object, an interactive app will open, allowing you to choose which cell to visualize from the drop-down option menu.
```{r plot_ratio_app, eval = FALSE}
plotRatio(tumor)
```
<center>
![Ratio Plot App](images/plot_ratio_shiny.png)
</center>

Providing a sample name to the `plotRatio()` function with the argument `sample_name`, will display the plot only for the selected cell.

```{r plot_ratio_sample, warning = FALSE}
plotRatio(tumor, "PMTC6LiverC117AL4L5S1_S885_L003_R1_001")
```

## runUmap()

The `runUmap()` function generates a [UMAP](https://umap-learn.readthedocs.io/en/latest/) embedding, which is stored in the `reducedDim` slot. 

`runUmap()` is an important pre-processing step for the `findClusters()` feature.

```{r run_umap}
tumor <- runUmap(tumor)
```

You can pass additional arguments to control UMAP parameters using the `'...'` argument. The full list of additional arguments that can be passed on to `uwot::umap`  with the '...' argument can be found in the [uwot manual](https://cran.r-project.org/web/packages/uwot/uwot.pdf) and information on their influence on clustering can be seen in the [UMAP webpage](https://umap-learn.readthedocs.io/en/latest/clustering.html)

## Clustering

The `findClusters()` function performs clustering using the UMAP embedding generated by `runUmap()`. For detecting subclones, CopyKit uses
different clustering algorithms such as:

1) [hdbscan](https://hdbscan.readthedocs.io/en/latest/how_hdbscan_works.html) (recommended)

2) [Leiden](https://www.nature.com/articles/s41598-019-41695-z)

3) [Louvain](https://arxiv.org/abs/0803.0476)

The hdbscan method is recommended and has been previously successfully applied in the work from Laks *et al.* and Minussi *et al.*.

### findSugestedK()

The `findSuggestedK()` is a helper function that provides guidance to choose the `k` parameter for clustering algorithms. The function 
`findSuggestedK` bootstraps clustering over a range of k values, and returns the value that maximizes the jaccard similarity, with *median* as the default metric (argument `metric`). 

While `findSuggestedK` does not guarantee optimal clustering. It  provides a guide to select k values.

```{r find_suggested_k}
tumor <- findSuggestedK(tumor)
```

The `plotSuggestedK()` function can be used to inspect the results of `findSuggestedK()`. It can plot a boxplot, heatmap (tile), or scatterplot

```{r plot_suggested_k_boxplot}
plotSuggestedK(tumor)
```

If the argument `geom` is set to *tile*, `plotSuggestedK()` plots a heatmap where each row is a detected subclone, each column is a k assessed during the grid search and the color represents the jaccard similarity for a given clone.

The suggested value can be accessed from the metadata:
```{r find_sug_meta}
S4Vectors::metadata(tumor)$suggestedK
```

### findClusters()

To run `findClusters()`, pass the CopyKit object as its input. If `findSuggestedK()` was run beforehand, `findClusters()` will automatically use the stored value from `findSuggestedK()` as the argument for k_subclones, unless otherwise specified.


```{r findCL_findSuggested}
tumor <- findClusters(tumor)
```

If hdbscan is used for clustering, singletons [outliers](https://hdbscan.readthedocs.io/en/latest/how_hdbscan_works.html) may be idetified and added to subgroup `c0`.  Copykit will notify you of any cells classified as c0 after running findClusters(). To remove outliers, subset the CopyKit object with:

```{r filter_outliers}
tumor <- tumor[,colData(tumor)$subclones != 'c0']
```

### plotUmap()

The `plotUmap()` function can be used to visualize the reduced dimensional embedding. Points can be colored by any element of the `colData` with the argument 'label'.

```{r}
plotUmap(tumor)
```

```{r plot_umap_subclones}
plotUmap(tumor, label = 'subclones')
```

## scquantum & calcInteger()

The scquantum package is integrated into CopyKit to infer absolute copy numbers. It can be used either within CopyKit or as a [standalone package](https://github.com/navinlabcode/scquantum) available on GitHub. Other methods for inferring absolute copy numbers are metadata and fixed. After running calcInteger(), CopyKit scales the segment ratios to integer values, which are stored in the integer slot and can be accessed using the assay() function.

To infer absolute ploidy values using scquantum, specify `scquantum` as the method argument in `calcInteger()`. The estimated computational ploidy is stored in `colData()` along with confidence_ratio, which compares the obtained score with the theoretical estimate, and ploidy_score, a transformation of confidence_ratio with values closer to 0 indicating better ploidy inference calls.

```{r calc_integerscquantum}
tumor <- calcInteger(tumor, method = 'scquantum')
```

The resulting `ploidy_score` scores can be used for further quality control of the single cell dataset.
```{r}
tumor <- tumor[,colData(tumor)$ploidy_score < 0.2]
```

Setting the method argument to 'fixed' scales all cells to a fixed value of ploidy (generally determined by flow cytometry), which is passed to CopyKit using the ploidy_value argument: 

```{r calc_integer_fixed, eval = FALSE}
tumor <- calcInteger(tumor, method = 'fixed', ploidy_value = 4.3)
```

If the integer assay exists, plotRatio() will plot it as a secondary axis.
```{r plot_ratio_integer, warning=FALSE}
plotRatio(tumor, "PMTC6LiverC117AL4L5S1_S885_L003_R1_001")
```

## plotHeatmap()

Copy number profiles can be visualized with a heatmap using the plotHeatmap() function. The elements of `colData()` can be annotated on the heatmap with the argument `label`. To order subclones, a consensus phylogeny can be calculated with `calcConsensus()` and `runConsensusPhylo()`, if the argument `order_cells` is not provided, the order of the cells in the heatmap will follow the order of the cells within the CopyKit object. In the plotHeatmap() function, gene annotations can be added with the genes argument. 

To visualize copy number profiles with a heatmap we can use `plotHeatmap()`. 

The heatmap can be annotated with elements of colData.

To order subclones, one option is to calculate a consensus phylogeny, explained in later sections:
```{r plot_heatmap_sub, fig.height=8}
tumor <- calcConsensus(tumor)
tumor <- runConsensusPhylo(tumor)
plotHeatmap(
  tumor,
  label = 'subclones',
  genes = c("TP53", "BRAF", "MYC"),
  order_cells = 'consensus_tree'
)
```

Integer copy number heatmaps can be plotted by passing assay = 'integer', with the integer matrix in the 'integer' slot. New information can be added to colData() and used in plotting functions. For example, spatial information encoded in the sample name can be extracted and added as a column to the metadata, and used to annotate the heatmap.
```{r plot_ht_int, fig.height=8}
# adding spatial information
colData(tumor)$spatial_info <- stringr::str_extract(colData(tumor)$sample, "L[0-9]")

# plotting the integer heatmap with the spatial and subclonal information
plotHeatmap(tumor, assay = 'integer', label = c("spatial_info", "subclones"), order_cells = 'consensus_tree')
```

The spatial information can now also be used to color the elements of the UMAP:
```{r umap_spatial}
plotUmap(tumor, label = 'spatial_info')
```

## runPhylo() & plotPhylo()

The `runPhylo()` function can be used to perform phylogenetic analysis of cells' copy number profiles. The available methods are [Neighbor Joining](https://pubmed.ncbi.nlm.nih.gov/3447015/) and [Balanced Minimum evolution](https://pubmed.ncbi.nlm.nih.gov/8412650/).The resulting tree is stored in the phylo slot within the CopyKit object. 

The `plotPhylo()` function can be used to visualize the trees generated by `runPhylo()`. The leaves of the tree can be colored based on any element of the colData by using the argument `label`.

```{r run_phylo}
tumor <- runPhylo(tumor, metric = 'manhattan')
plotPhylo(tumor, label = 'subclones')
```

## plotFreq()

The `plotFreq()` function can be used to visualize genomic gains or losses across the genome. This function calculates the frequency of gain or losses in each region of the genome based on a threshold applied to all samples. The `low_threshold` argument (below which values are counted as genomic losses) and `high_threshold` argument (above which values are counted as genomic gains) control the thresholds. It is recommended to set the thresholds based on the ploidy of the sample. To use the integer assay instead of the default segment_ratios assay, pass the `assay` argument. The visual representation of the frequencies can be shown as either an `area` or a `line` geom

```{r plot_freq_sample}
plotFreq(tumor)
```

Elements of `colData()` can be used to split the plot across different groups.

```{r plot_freq_label, fig.height=6}
plotFreq(tumor,
         group = 'subclones')
```

## calcConsensus()

Consensus sequences can help visualize the different segments across subclones. To calculate consensus matrices we can use `calcConsensus()`.
```{r calc_consensus}
tumor <- calcConsensus(tumor)
```

`plotHeatmap()` can plot a consensus heatmap:
```{r plot_heat_consensus}
plotHeatmap(tumor, consensus = TRUE, label = 'subclones')
```

`plotHeatmap()` can annotate the consensus heatmap with information from the metadata as long as label is the same as the information used to build the consensus matrix:
```{r plot_heat_freq_bar}
plotHeatmap(tumor, consensus = TRUE, label = 'subclones', group = 'spatial_info')
```

By default `calcConsensus()` uses the subclones information to calculate a consensus for each subclone.
Any element of the `colData()` can be used to calculate the consensus.

**Note:** Consensus matrices can be calculated from the integer assay. Importantly, the integer matrix must be in the `assay(tumor, 'integer')` slot. Check `calcInteger()` for more info.
```{r eval = FALSE}
tumor <- calcConsensus(tumor, consensus_by = 'subclones', assay = 'integer')
```

## plotConsensusLine()

To compare the differences among subclones, `plotConsensusLine()` opens an interactive app where the consensus sequences are plotted as lines.

```{r calc_consensus_again, echo = FALSE}
tumor <- calcConsensus(tumor)
```

```{r plot_cons_line, eval=FALSE}
plotConsensusLine(tumor)
```

<center>
![Plot Consensus Line](images/plot_consensus_shiny.png)
</center>

## plotGeneCopy()

To check copy number states across of genes we can use `plotGeneCopy()`. Two different geoms: “swarm” (default) or “violin” can be applied. 

As with other plotting functions, points can be colored with the argument 'label'.

```{r}
plotGeneCopy(tumor, genes = c("CDKN2A",
                              "FGFR1",
                              "TP53",
                              "PTEN",
                              "MYC",
                              "CDKN1A",
                              "MDM2",
                              "AURKA",
                              "PIK3CA",
                              "CCND1",
                              "KRAS"),
                      label = 'spatial_info')
```

A positional dodge can be added to facilitate the visualization across groups:
```{r}
plotGeneCopy(tumor, 
             genes = c("CDKN2A",
                              "FGFR1",
                              "TP53",
                              "PTEN",
                              "MYC",
                              "CDKN1A",
                              "MDM2",
                              "AURKA",
                              "PIK3CA",
                              "CCND1",
                              "KRAS"),
             label = 'subclones',
             dodge.width = 0.8)
```


A barplot geom is also provided to visualize the integer data as a frequency barplot for each gene:
```{r plot_gene_copy_integer}
plotGeneCopy(tumor, genes = c("CDKN2A",
                              "FGFR1",
                              "TP53",
                              "PTEN",
                              "MYC",
                              "CDKN1A",
                              "MDM2",
                              "AURKA",
                              "PIK3CA",
                              "CCND1",
                              "KRAS"),
             geom = 'barplot',
             assay = 'integer')
```

## plotAlluvial()

To visualize frequencies across elements of the metadata we can use `plotAlluvial()` 
```{r plot_alluvial}
plotAlluvial(tumor, label = c("subclones", "spatial_info"))
```

## runPca()

Principal Component Analysis can be run with `runPca()`
```{r run_pca}
tumor <- runPca(tumor)
```

The results are stored in the `reducedDim(tumor, 'PCA')` slot.

Principal Components can be used as an alternative pre-processing step to the `findClusters()` function by changing `findClusters()` _embedding_ argument to 'PCA'. The number of principal components to be used for clustering can also be set within `findClusters() with the argument ncomponents. At this time better results are achieved by using the default UMAP embedding and it is the recommend pre-processing step. However PCA remains as a viable alternative

### plotScree
To determine the number of useful principal components a scree plot can be shown with:
```{r plot_scree}
plotScree(tumor)
```

### plotPCA
To visualize the first 2 principal components you can use `plotPca()`.
```{r}
plotPca(tumor, label = 'spatial_info')
```

